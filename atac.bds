#!/usr/bin/env bds
#vim: syntax=java


help == atac pipeline settings

se 		:= false 	help Single ended data.
trimmed_fastq 	:= false	help Skip fastq-trimming stage.
mapping	 	:= false	help Mapping only (no macs2 peak calling or IDR).
vplot 		:= false 	help Create V plot.
preseq 		:= false 	help Do preseq analysis.
subsample 	:= false 	help Subsample replicates. Use '-nreads [NO_READS]' (default: 15000000) to specify # reads to subsample.
true_rep 	:= false 	help No pseudo-replicates.
idr 		:= false 	help Perform IDR analysis on called peaks. This will change p-value threshold (0.01->0.1) in MACS2 peak calling.
no_ataqc 	:= false 	help No ATAQC
csem	 	:= false	help Use CSEM for alignment.
//ataqc(parameters to be defined: species, blacklist, dnase, tss, prom, enh, reg2map and roadmap_meta).
mem_ataqc 	:= "8G"		help Max. memory for ATAQC (default: 8G).
smooth_win 	:= "150" 	help Smoothing window size for MACS2 peak calling (default: 150).

help() // show help contexts

include "modules/input_fastq.bds"
include "modules/input_bam.bds"
include "modules/align_bowtie.bds"
include "modules/align_bowtie2.bds"
include "modules/align_etc.bds"
include "modules/vplot.bds"
include "modules/postalign_bam.bds"
include "modules/postalign_bed.bds"
include "modules/preseq.bds"
include "modules/callpeak_macs2.bds"
include "modules/callpeak_etc.bds"
include "modules/idr.bds"

input := ""

// Global variable for output filenames ( map with key $rep )
string{} fastq, align_log, bam, filt_bam, dup_qc, flagstat_nodup_qc, pbc_qc, xcor_qc, xcor_plot
string{} pval_bigwig, fc_bigwig
string{} shifted_tags, shifted_tags_pr1, shifted_tags_pr2
string{} peaks, peaks_pr1, peaks_pr2
string peak_pooled, peak_ppr1, peak_ppr2, peak_overlap
string idr_tr, idr_pr_rep1, idr_pr_rep2, idr_ppr, idr_opt, idr_consv
string idr_tr_png, idr_pr_rep1_png, idr_pr_rep2_png, idr_ppr_png
string idr_qc


init_atac()

chk_input_data()

atac()

post_atac()

do_idr()

report()



void init_atac() {

	if ( is_input_legacy() ) { // legacy input method taking first 8 parameters from cmd. line

		bwt2_idx 	= args[0].trim()
		fastq1_1	= args[1].trim()
		fastq1_2	= args[2].trim()
		nth_bwt2	= args[3].trim().parseInt()
		gensz		= args[4].trim()
		chrsz		= args[5].trim()
		vplot_idx 	= args[6].trim()
		out_dir 	= args[7].trim()

		se 		= false

		vplot 		= true
		preseq 		= true

		mapping 	= false

		true_rep 	= true
		no_ataqc	= true

		csem 		= false

		input 		= "fastq"

		print("\n\nLegacy input method found (8 parameters)\n")
		print("========================================\n")
		print( "Bowtie2 index\t\t: $bwt2_idx\n" )
		print( "Read 1\t\t\t: $fastq1_1\n" )
		print( "Read 2\t\t\t: $fastq1_2\n" )
		print( "# threads (bowtie2)\t: $nth_bwt2\n")
		print( "Genome size (hs,mm)\t: $gensz\n" )
		print( "Chromosome sizes file\t: $chrsz\n" )
		print( "V-Plot index\t\t: $vplot_idx\n" )
		print( "Output dir.\t\t: $out_dir\n" )
	}
	else {
		se 		= get_conf_val_bool( se,		["se"] )

		trimmed_fastq 	= get_conf_val_bool( trimmed_fastq,	["trimmed_fastq"] )

		mapping		= get_conf_val_bool( mapping,		["mapping"] )

		vplot 		= get_conf_val_bool( vplot,		["vplot"] )
		preseq 		= get_conf_val_bool( preseq,		["preseq"] )
		subsample	= get_conf_val_bool( subsample, 	["subsample"] )
		true_rep	= get_conf_val_bool( true_rep, 		["true_rep"] )

		idr 		= get_conf_val_bool( idr, 		["idr"] )
		no_ataqc 	= get_conf_val_bool( no_ataqc, 		["no_ataqc"] )

		csem 		= get_conf_val_bool( csem, 		["csem"] )

		mem_ataqc	= get_conf_val( mem_ataqc,		["mem_ataqc"] )

		smooth_win	= get_conf_val( smooth_win,		["smooth_win"] )
	}

	if ( input == "" ) { // determine input type

		if ( get_filt_bam(0,1) != "" ) 	input = "filt_bam"
		if ( get_bam(0,1) != "" ) 	input = "bam"
		if ( get_fastq(0,1,1) != "" ) 	input = "fastq"
	}

	fraglen0 = true // set fragment length as zero for cross corr. analysis

	rm_chr_from_tag = "chrM"; // remove lines with chrM in _bam_to_tag

	print_atac()
}

void print_atac() {

	print( "\n\n== atac pipeline settings\n")
	print( "Single ended data set?\t: $se\n")
	print( "Input data type\t\t: $input\n")
	print( "Fastqs are trimmed?\t: $trimmed_fastq\n")
	print( "# Replicates\t\t: "+ get_num_rep() + "\n")
	print( "MACS2 peak calling\t: " + !mapping + "\n")
	print( "Subsample replicates\t: $subsample\n")
	print( "No pseudo replicates\t: $true_rep\n")
	print( "Perform IDR analysis on peaks\t: $idr\n")
	print( "Vplot generation\t: $vplot\n")
	print( "Preseq analysis\t\t: $preseq\n")
	print( "No ATAQC (advanced QC report including vplot and preseq)\t: $no_ataqc\n")
	print( "Use CSEM for alignment\t: $csem\n")
	print( "Max. memory for ATAQC\t: $mem_ataqc\n")
	print( "Smoothing window for MACS2\t: $smooth_win\n")
}

void chk_input_data() {

	print( "\n\n== checking atac inputs (data type = $input) ...\n\n" );

	if ( is_input_filt_bam() && ( vplot || preseq ) ) {
		error("Preseq analysis (-preseq) and vplot (-vplot) are not available if pipeline starts from filtered bam files (with '-filt_bam [FILT_BAM_PATH]...')!\n")
	}

	if ( !is_input_fastq() && !no_ataqc ) {
		print("\nWarning: ATAQC is available for fastq inputs only. Disabling ATAQC...\n")
		no_ataqc = true
	}

	if ( !se && csem ) {
		error("CSEM (-csem) is not available for single-ended data set ('-se')!\n")
	}

	if ( get_num_rep() != 2 && idr ) {
		print("\nWarning: IDR is available for two replicates only. Disabling IDR...\n")
		idr 	= false
	}

	if ( is_input_fastq() ) chk_align_bwt2()
	if ( !mapping ) 	chk_callpeak_macs2()
	if ( vplot ) 		chk_vplot()
	if ( idr ) 		chk_idr()
	if ( !no_ataqc ) 	chk_ataqc()

	if ( idr ) {
		if ( idr_thresh == "0.02" ) {
			print("\nDefault IDR threshold is found ($idr_thresh). Set it to 0.1 .\n")
			idr_thresh = 0.1
		}

		print("\nSet p-value threshold in MACS2 peak calling to 0.1 .\n")

		pval_thresh_macs2 = 0.1
	}

	// check data files
	suffix := se ? " (SE)" : " (PE)"

	string[] data_all

	for ( int rep=1; rep <= get_num_rep(); rep++) {

		string[] data

		string prefix

		if ( is_input_fastq() ) {
			prefix = "Rep$rep fastq" + suffix
			fastqs := get_fastqs( 0, rep )

			if ( !se && (get_num_rep()==1) && (fastqs.size()<2) && (get_fastq( 0, 2, 1 )!="") ) fastqs.add( get_fastq( 0, 2, 1 ) )

			if ( !se && fastqs.size() < 2 ) error("A pair of fastqs are needed for replicate $rep (if it's single-ended add '-se')\n")

			if ( fastqs.size()==0 ) {
				data.push( "" )
			}
			else {
				for ( string fastq : fastqs ) data.push( fastq )
			}

			if ( fastqs.size()==0 ) error("No fastq defined for replicate $rep\n")
		}
		else if ( is_input_bam() ) {
			prefix = "Rep$rep bam" + suffix
			data.push( get_bam( 0, rep ) )
		}
		else if ( is_input_filt_bam() ) {
			prefix = "Rep$rep filt_bam" + suffix
			data.push( get_filt_bam( 0, rep ) )
		}
		else {
			error("Unspported input type (-input)!")
		}

		print("$prefix :\n")

		for ( string s : data ) {
			print("\t$s\n")
			if ( (s != "") && !path_exists(s) ) error("\t\tFile not found!\n")
		}

		if ( data[0] == "" ) {
			error( "\t$prefix missing!\n")
		}

		// check any duplicate input filename
		for ( string s : data ) {
			if ( is_in_array( get_basename( s ), get_basename( data_all ) ) ) \
				error( "\t$prefix has duplicate filename!\n")
		}

		data_all = concat( data_all, data )
	}

}

void chk_ataqc() {

	print("\nChecking parameters and data files for ATAQC. If you don't want ATAQC then add '-no_ataqc'\n\n")

	if ( species == "" ) error("Genome name is missing ( '-species [GENOME_NAME; hg19, mm9, ...]' )!\n" )
	if ( ref_fa == "" ) error("Specify your reference genome .fa ('-ref_fa [FA]')!\n")
	if ( vplot_idx == "" ) error("V plot index is missing ( '-vplot_idx' )!\n")
	if ( dnase == "" ) error("DNase bed is missing ( '-dnase' )!\n")
	if ( blacklist == "" ) error("Blacklist bed is missing ( '-blacklist' )!\n")
	if ( prom == "" ) error("Promoter bed is missing ( '-prom' )!\n")
	if ( enh == "" ) error("Enhancer bed is missing ( '-enh' )!\n")
	if ( reg2map == "" ) error("reg2map is missing ( '-reg2map' )!\n")
	if ( roadmap_meta == "" ) error("Roadmap metadata are missing ( '-roadmap_meta' )!\n")
}

void atac() {

	for (int rep=1; rep<=get_num_rep(); rep++) {

		par _atac( rep )
	}

	wait
}

void _atac( int rep ) {

	if ( se ) 	_atac_SE( rep )
	else 		_atac_PE( rep )

	wait_par_rep()
}

void _atac_SE( int rep ) {

	info := "rep$rep"

	atac_out_dir := mkdir_path( (get_num_rep()==1) ? out_dir : "$out_dir/$info" )

	if ( is_input_fastq() ) {

		fastqs := get_fastqs( 0, rep )

		fastq{rep} = fastqs[0]

		string p1, label_fastq

		if ( trimmed_fastq ) {
			p1 = fastq{rep}
		}
		else {
			p1 = _trim_adapters( fastq{rep}, atac_out_dir, info )
		}
		wait

		fastq_graph_id := trimmed_fastq ? "fastq\\n($info)" : "trimmed\\nfastq\\n($info)"

		if ( csem ) {
			( bam{rep}, align_log{rep} ) = _bowtie2_csem( p1, atac_out_dir, info, fastq_graph_id, "bam\\n($info)" )
		}
		else {
			( bam{rep}, align_log{rep} ) = _bowtie2( p1, atac_out_dir, info, fastq_graph_id, "bam\\n($info)" )
		}
		wait
	}

	if ( is_input_fastq() || is_input_bam() ) {

		if ( is_input_bam() ) bam{rep} = get_bam( 0, rep )

		( filt_bam{rep}, dup_qc{rep}, flagstat_nodup_qc{rep}, pbc_qc{rep} ) = _dedup_bam( bam{rep}, atac_out_dir, info )
		wait
	}

	if ( is_input_fastq() || is_input_bam() || is_input_filt_bam() ) {

		if ( is_input_filt_bam() ) filt_bam{rep} = get_filt_bam( 0, rep )
	}

	string subsampled_tag

	if ( !mapping ) {

		tag := _bam_to_tag( filt_bam{rep}, atac_out_dir, info, "filt_bam\\n($info)", "tagalign\\n($info)" )
		wait

		if ( subsample ) {
			subsampled_tag = _subsample_tag( tag, atac_out_dir, info )
			wait
		}
		else {
			subsampled_tag = tag
		}

		shifted_tags{rep} = _shift_tag( subsampled_tag, atac_out_dir, info )
		wait

		tag_graph_id := subsample ? "subsampled\\ntagalign\\n($info)" : "tagalign\\n($info)"

		( peaks{rep}, fc_bigwig{rep}, pval_bigwig{rep} )  = _macs2_atac( shifted_tags{rep}, "$smooth_win", atac_out_dir, info, tag_graph_id )

		if ( !true_rep ) {

			( shifted_tags_pr1{rep}, shifted_tags_pr2{rep} ) = _spr( shifted_tags{rep}, atac_out_dir, info, \
									tag_graph_id, "tagalign pr1\\n($info)", "tagalign pr2\\n($info)" )
			wait

			( peaks_pr1{rep}, fc_bigwig{rep+"_pr1"}, pval_bigwig{rep+"_pr1"} ) \
					= _macs2_atac( shifted_tags_pr1{rep}, "$smooth_win", atac_out_dir, info + "_pr1", "tagalign pr1\\n($info)" )

			( peaks_pr2{rep}, fc_bigwig{rep+"_pr2"}, pval_bigwig{rep+"_pr2"} ) \
					= _macs2_atac( shifted_tags_pr2{rep}, "$smooth_win", atac_out_dir, info + "_pr2", "tagalign pr2\\n($info)" )
		}
	}

	if ( bam.hasKey(rep) ) {

		string sorted_bam

		if ( vplot || preseq || !mapping && !no_ataqc ) sorted_bam = _srt_bam( bam{rep}, atac_out_dir, info )
		wait

		if ( !mapping && !no_ataqc ) {

			report_dir := mkdir_path( "$atac_out_dir/ataqc" )

			_ataqc( fastq{rep}, "", bam{rep}, align_log{rep}, sorted_bam, \
				dup_qc{rep}, filt_bam{rep}, shifted_tags{rep}, pval_bigwig{rep}, peaks{rep}, \
				report_dir, info )
		}
		else {

			if ( vplot ) _vplot( sorted_bam, atac_out_dir, info )

			if ( preseq ) _preseq( sorted_bam, atac_out_dir, info )

			//wait

			//_report_atac( atac_out_dir, info )
		}
	}

	if ( !mapping && subsampled_tag != "" ) { // cross correlation analysis

		( xcor_qc{rep}, xcor_plot{rep} ) = _xcor( subsampled_tag, atac_out_dir, info )
	}

	wait
}

void _atac_PE( int rep ) {

	info := "rep$rep"

	atac_out_dir := mkdir_path( (get_num_rep()==1) ? out_dir : "$out_dir/$info" )

	if ( is_input_fastq() ) {

		fastqs := get_fastqs( 0, rep )

		string p1, p2

		// correct if user skipped replicate id like (-fastq[PAIR]) instead of (-fastq[REP]_[PAIR])
		if ( (get_num_rep()==1) && (fastqs.size()<2) && (get_fastq( 0, 2, 1 )!="") ) fastqs.add( get_fastq( 0, 2, 1 ) )

		fastq1 := fastqs[0]
		fastq2 := fastqs[1]

		fastq{rep+",1"} = fastq1
		fastq{rep+",2"} = fastq2

		if ( trimmed_fastq ) {
			p1 = fastq1
			p2 = fastq2
		}
		else {
			( p1, p2 ) = _trim_adapters_PE( fastq1, fastq2, atac_out_dir, info )
			wait
		}

		fastq_graph_id1 := trimmed_fastq ? "fastq1\\n($info)" : "trimmed\\nfastq1\\n($info)"
		fastq_graph_id2 := trimmed_fastq ? "fastq2\\n($info)" : "trimmed\\nfastq2\\n($info)"

		( bam{rep}, align_log{rep} ) = _bowtie2_PE( p1, p2, atac_out_dir, info, \
							fastq_graph_id1, fastq_graph_id2, "bam\\n($info)" )
		wait

	}

	if ( is_input_fastq() || is_input_bam() ) {

		if ( is_input_bam() ) bam{rep} = get_bam( 0, rep )

		(filt_bam{rep}, dup_qc{rep}, flagstat_nodup_qc{rep}, pbc_qc{rep} ) = _dedup_bam_PE( bam{rep}, atac_out_dir, info )
		wait
	}

	if ( is_input_fastq() || is_input_bam() || is_input_filt_bam() ) {

		if ( is_input_filt_bam() ) filt_bam{rep} = get_filt_bam( 0, rep )
	}

	string tag

	if ( !mapping ) {

		if ( subsample || !true_rep ) {

			bedpe := _bam_to_bedpe( filt_bam{rep}, atac_out_dir, info, "filt_bam\\n($info)", "bedpe\\n($info)" )
			wait

			string subsampled_bedpe

			if ( subsample ) {

				subsampled_bedpe = _subsample_bedpe( bedpe, atac_out_dir, info )
			}
			else {
				subsampled_bedpe = bedpe
			}
			wait

			tag_graph_id := subsample ? "subsampled\\nbedpe\\n($info)" : "bedpe\\n($info)"

			tag = _bedpe_to_tag( subsampled_bedpe, atac_out_dir, info )
			wait

			shifted_tags{rep} = _shift_tag( tag, atac_out_dir, info )

			if ( !true_rep ) {

				string tag_pr1, tag_pr2
				(tag_pr1, tag_pr2) = _spr_PE( subsampled_bedpe, atac_out_dir, info, \
							tag_graph_id, "tagalign pr1\\n($info)", "tagalign pr2\\n($info)" )
				wait

				shifted_tags_pr1{rep} = _shift_tag( tag_pr1, atac_out_dir, info )
				shifted_tags_pr2{rep} = _shift_tag( tag_pr2, atac_out_dir, info )
			}
			wait

			if ( !subsample ) {

				shifted_tags{rep} = _bam_to_bed_atac( filt_bam{rep}, atac_out_dir, info )
				wait
			}

			if ( !true_rep ) {

				( peaks_pr1{rep}, fc_bigwig{rep+"_pr1"}, pval_bigwig{rep+"_pr1"} ) \
					= _macs2_atac( shifted_tags_pr1{rep}, "$smooth_win", atac_out_dir, info + "_pr1", "tagalign pr1\\n($info)" )

				( peaks_pr2{rep},  fc_bigwig{rep+"_pr2"}, pval_bigwig{rep+"_pr2"} ) \
					= _macs2_atac( shifted_tags_pr2{rep}, "$smooth_win", atac_out_dir, info + "_pr2", "tagalign pr2\\n($info)" )
			}
		}
		else {
			shifted_tags{rep} = _bam_to_bed_atac( filt_bam{rep}, atac_out_dir, info )
			wait
		}

		( peaks{rep}, fc_bigwig{rep}, pval_bigwig{rep} ) = _macs2_atac( shifted_tags{rep}, "$smooth_win", atac_out_dir, info )
	}

	if ( bam.hasKey(rep) ) {

		string sorted_bam

		if ( vplot || preseq || !mapping && !no_ataqc ) sorted_bam = _srt_bam( bam{rep}, atac_out_dir, info )
		wait

		if ( !mapping && !no_ataqc ) {

			report_dir := mkdir_path( "$atac_out_dir/ataqc" )

			_ataqc( fastq{rep+",1"}, fastq{rep+",2"}, bam{rep}, align_log{rep}, sorted_bam, \
				dup_qc{rep}, filt_bam{rep}, shifted_tags{rep}, pval_bigwig{rep}, peaks{rep}, \
				report_dir, info )
		}
		else {

			if ( vplot ) _vplot( sorted_bam, atac_out_dir, info )

			if ( preseq ) _preseq( sorted_bam, atac_out_dir, info )

			//wait
			//_report_atac( atac_out_dir, info )
		}
	}

	if ( !mapping && tag != "" ) { // cross correlation analysis

		( xcor_qc{rep}, xcor_plot{rep} ) = _xcor( tag, atac_out_dir, info )
	}

	wait
}

void post_atac() {

	if ( mapping ) return

	if ( get_num_rep() != 2 ) return

	pooled_out_dir := mkdir_path( "$out_dir/pooled_replicate" )

	string shifted_tag_pooled

	if ( !true_rep ) {

		// Make shifted tags for pooled pseudo rep (ppr).
		string shifted_tag_ppr1, shifted_tag_ppr2

		( shifted_tag_pooled, shifted_tag_ppr1, shifted_tag_ppr2 ) = \
			_ppr( 	shifted_tags{1}, shifted_tags_pr1{1}, shifted_tags_pr2{1}, \
				shifted_tags{2}, shifted_tags_pr1{2}, shifted_tags_pr2{2}, pooled_out_dir, "" )
		wait

		// call peaks on ppr
		string tmp

		( peak_ppr1, fc_bigwig{"ppr1"}, pval_bigwig{"ppr1"} ) \
			= _macs2_atac( shifted_tag_ppr1, "$smooth_win", pooled_out_dir, "ppr1", "tagalign\\n(ppr1)" )

		( peak_ppr2, fc_bigwig{"ppr2"}, pval_bigwig{"ppr2"} ) \
			= _macs2_atac( shifted_tag_ppr2, "$smooth_win", pooled_out_dir, "ppr2", "tagalign\\n(ppr2)" )

		( peak_pooled, fc_bigwig{"pooled"}, pval_bigwig{"pooled"} ) \
			= _macs2_atac( shifted_tag_pooled, "$smooth_win", pooled_out_dir, "pooled", "tagalign\\n(pooled)" )

		wait

		peak_overlap =  _naive_overlap_thresh_narrowpeak( peak_pooled, peaks{1}, peaks{2}, \
								peak_ppr1, peak_ppr2, pooled_out_dir, "final" )
	}
	else {
		shifted_tag_pooled = _pool_tag( shifted_tags{1}, shifted_tags{2}, pooled_out_dir, "" )
		wait

		string tmp
		( peak_pooled, tmp ) = _macs2_atac( shifted_tag_pooled, "$smooth_win", pooled_out_dir, "pooled", "tagalign\\n(pooled)" )
	}

	wait
}

void do_idr() {

	if ( mapping ) return

	if ( !idr || get_num_rep() != 2 ) return

	idr_out_dir := mkdir_path( "$out_dir/idr2" )

	rep1_dir   := "$out_dir/rep1"
	rep2_dir   := "$out_dir/rep2"
	pooled_dir := "$out_dir/pooled_replicate"

	// take top $npeak_filt lines from narrowpeaks for idr

	string{} filt_peaks, filt_peaks_pr1, filt_peaks_pr2
	string filt_peak_pooled, filt_peak_ppr1, filt_peak_ppr2

	filt_peaks{1} 	= _filt_out_bad_npeaks( peaks{1}, rep1_dir, "rep1" )
	filt_peaks{2} 	= _filt_out_bad_npeaks( peaks{2}, rep2_dir, "rep2"  )
	filt_peak_pooled= _filt_out_bad_npeaks( peak_pooled, pooled_dir, "pooled" )

	if ( !true_rep ) {

		filt_peaks_pr1{1} = _filt_out_bad_npeaks( peaks_pr1{1}, rep1_dir, "rep1_pr1" )
		filt_peaks_pr2{1} = _filt_out_bad_npeaks( peaks_pr2{1}, rep1_dir, "rep1_pr2" )
		filt_peaks_pr1{2} = _filt_out_bad_npeaks( peaks_pr1{2}, rep2_dir, "rep2_pr1" )
		filt_peaks_pr2{2} = _filt_out_bad_npeaks( peaks_pr2{2}, rep2_dir, "rep2_pr2" )

		filt_peak_ppr1 	   = _filt_out_bad_npeaks( peak_ppr1, pooled_dir, "ppr1" )
		filt_peak_ppr2 	   = _filt_out_bad_npeaks( peak_ppr2, pooled_dir, "ppr2" )
	}

	wait

	string tmp

	// idr for true reps
	(idr_tr, idr_tr_png) = _idr2( filt_peaks{1}, filt_peaks{2}, filt_peak_pooled, idr_out_dir, "true", \
				"n peak filt\\n(rep1)","n peak filt\\n(rep2)","n peak filt\\n(pooled)" )

	if ( !true_rep ) {

		// idr on pseudo reps
		(idr_pr_rep1, idr_pr_rep1_png) = _idr2( filt_peaks_pr1{1}, filt_peaks_pr2{1}, filt_peaks{1}, idr_out_dir, "rep1_pr", \
						"n peak filt\\n(rep1_pr1)","n peak filt\\n(rep1_pr2)","n peak filt\\n(rep1)" )

		(idr_pr_rep2, idr_pr_rep2_png) = _idr2( filt_peaks_pr1{2}, filt_peaks_pr2{2}, filt_peaks{2}, idr_out_dir, "rep2_pr", \
						"n peak filt\\n(rep2_pr1)","n peak filt\\n(rep2_pr2)","n peak filt\\n(rep2)" )

		// idr on ppr
		(idr_ppr, idr_ppr_png) = _idr2( filt_peak_ppr1, filt_peak_ppr2, filt_peak_pooled, idr_out_dir, "ppr", \
						"n peak filt\\n(ppr1)","n peak filt\\n(ppr2)","n peak filt\\n(pooled)" )
		wait

		(idr_qc, idr_opt, idr_consv)  = _idr_final_qc( idr_tr, idr_pr_rep1, idr_pr_rep2, idr_ppr, idr_out_dir, "" )
	}

	wait
}

string[] _ataqc( string fastq1, string fastq2, string bam, string align_log, string srt_bam, \
		 string dup_log, string filt_bam, string bed, string bigwig, string peak, \
		 string o_dir, string info ) {

	prefix 		:= replace_dir( rm_ext( fastq1, ["fastq","fq"] ), o_dir ) + ( (fastq2!="") ? ".PE2SE" : "" )
	html 		:= "$prefix"+"_qc.html"
	txt 		:= "$prefix"+"_qc.txt"
	prefix_basename := get_basename( prefix )
	param_fastq 	:= (fastq2!="") ? "--fastq1 $fastq1 --fastq2 $fastq2" : "--fastq1 $fastq1"

	in  	:= (fastq2!="") ? [ fastq1, fastq2, bam, align_log, srt_bam, dup_log, filt_bam, bed, bigwig, peak ] \
				: [ fastq1, bam, align_log, srt_bam, dup_log, filt_bam, bed, bigwig, peak ]
	out 	:= [ html, txt ] //, gc_plot, hist_graph, lg_vplot, vplot, signal ]

	taskName:= "ataqc "+info

	task( out<-in ) {

		sys $shcmd_init

		sys cd $o_dir

		sys python $script_dir/ataqc/run_ataqc.py \
		    --workdir $o_dir \
		    --outdir $o_dir \
		    --outprefix $prefix_basename \
		    --genome $species \
		    --ref $ref_fa \
		    --tss $vplot_idx \
		    --dnase $dnase \
		    --blacklist $blacklist \
		    --prom $prom \
		    --enh $enh \
		    --reg2map $reg2map \
		    --meta $roadmap_meta \
		    $param_fastq \
		    --alignedbam $bam \
		    --alignmentlog $align_log \
		    --coordsortbam $srt_bam \
		    --duplog $dup_log \
		    --finalbam $filt_bam \
		    --finalbed $bed \
		    --bigwig $bigwig \
		    --peaks $peak
	}

	wait_par()

	label_in := ( fastq2!="" ) ? ["fastq1\\n($info)","fastq2\\n($info)","bam\\n($info)","srt_bam\\n($info)",\
				      "filt_bam\\n($info)","tagalign\\n($info)","pval sig.\\n($info)","n peak\\n($info)"] \
				   : ["fastq\\n($info)","bam\\n($info)","srt_bam\\n($info)",\
				      "filt_bam\\n($info)","tagalign\\n($info)","pval sig.\\n($info)","n peak\\n($info)"]

	path_in := ( fastq2!="" ) ? [fastq1, fastq2, bam, srt_bam, filt_bam, bed, bigwig, peak] \
				  : [fastq1, bam, srt_bam, filt_bam, bed, bigwig, peak]

	_add_to_graphviz( label_in, path_in, ["ataqc rpt\\n($info)"], [html], "ataqc\\n($info)", grp_color_ataqc )

	return out
}

void report() { // HTML atac report

	wait

	html := report_header.read()

	html += _html_atac_files() 	// treeview for directory and file structure
	html += _html_atac_tracks() 	// epigenome browser tracks
	html += _html_atac_graphviz() 	// graphviz workflow diagram
	html += _html_atac_QC()	 	// show QC tables and images

	html += "<br></body></html>"

	report_file.write( html )
}

string _html_atac_graphviz() {

	html := "<div id='atac_graphviz'><b>Workflow diagram</b>"

	html += _html_graphviz()

	html += "</div><br>\n"
	return html
}

string _html_atac_files() {

	html := "<div id='atac_files'><b>Directories and files</b>"

	html += "<table id='filetable'> <caption>"+\
		"<a href='#' onclick=\"jQuery('#filetable').treetable('expandAll'); return false;\">Expand all</a> &nbsp&nbsp" + \
		"<a href='#' onclick=\"jQuery('#filetable').treetable('collapseAll'); return false;\">Collapse all</a>" + \
		"</caption> <thead><tr><th>Files</th><th>Path</th></tr></thead> <tbody>"

	for ( int rep=1; rep <= get_num_rep(); rep++) {

		info 	:= get_num_rep()==1 ? "." : "rep$rep"
		key 	:= "$rep"

		align_out_dir 	:= "$out_dir/$info"

		html += "<tr data-tt-id='$key'><td>" + "Replicate $rep ($info)"+ "</td><td>"+ _html_link_url( align_out_dir ) +"</td></tr>"

		// replicates and controls
		if ( fastq.hasKey(key+",1") ) {
			html += "<tr data-tt-id='fastq_$key"+"_1' data-tt-parent-id='$key'><td>" + "fastq pair 1" + "</td><td>"+_html_link_url( fastq{key+",1"} )+"</td></tr>"
			html += "<tr data-tt-id='fastq_$key"+"_2' data-tt-parent-id='$key'><td>" + "fastq pair 2" + "</td><td>"+_html_link_url( fastq{key+",2"} )+"</td></tr>"
		}
		else if ( fastq.hasKey(key) ) {
			html += "<tr data-tt-id='fastq_$key' data-tt-parent-id='$key'><td>" + "fastq" + "</td><td>"+_html_link_url( fastq{key} )+"</td></tr>"
		}

		if ( bam.hasKey(key) ) 	    	html += "<tr data-tt-id='bam_$key' data-tt-parent-id='$key'><td>" + "bam" + "</td><td>"+_html_link_url( bam{key} )+"</td></tr>"
		if ( filt_bam.hasKey(key) ) 	html += "<tr data-tt-id='filt_bam_$key' data-tt-parent-id='$key'><td>" + "filtered bam" + "</td><td>"+_html_link_url( filt_bam{key} )+"</td></tr>"
		if ( shifted_tags.hasKey(key) ) html += "<tr data-tt-id='tag_$key' data-tt-parent-id='$key'><td>" + "tagalign" + "</td><td>"+_html_link_url( shifted_tags{key} )+"</td></tr>"
	}

	// signal track

	if ( pval_bigwig.hasKey("1") ) {

		html += "<tr data-tt-id='signal'><td>" + "Signal track"+ "</td><td>"+ "" +"</td></tr>"

		// true rep
		html += "<tr data-tt-id='signal_trk_truerep' data-tt-parent-id='signal'><td>" + "True replicates"+ "</td><td></td></tr>"

		for ( int rep=1; rep <= get_num_rep(); rep++) {

			if ( pval_bigwig.hasKey(rep) ) html += "<tr data-tt-id='signal_trk_$rep' data-tt-parent-id='signal_trk_truerep'><td>" + "pval (rep$rep)"+ "</td><td>"+ _html_link_url( pval_bigwig{rep} ) +"</td></tr>"
			if ( fc_bigwig.hasKey(rep) ) html += "<tr data-tt-id='signal_trk_$rep' data-tt-parent-id='signal_trk_truerep'><td>" + "fc (rep$rep)"+ "</td><td>"+ _html_link_url( fc_bigwig{rep} ) +"</td></tr>"
		}

		// pseudo rep
		if ( pval_bigwig.hasKey("rep1_pr1") ) \
			html += "<tr data-tt-id='signal_trk_pr' data-tt-parent-id='signal'><td>" + "Pseudo replicates"+ "</td><td></td></tr>"

		for ( int rep=1; rep <= get_num_rep(); rep++) {
			if ( pval_bigwig.hasKey("rep$rep"+"_pr1") ) html += "<tr data-tt-id='signal_trk_pr1_$rep' data-tt-parent-id='signal_trk_pr'><td>" + "pval (rep$rep pr1)"+ "</td><td>"+ _html_link_url( pval_bigwig{"rep$rep"+"_pr1"} ) +"</td></tr>"
			if ( fc_bigwig.hasKey("rep$rep"+"_pr1") ) html += "<tr data-tt-id='signal_trk_pr1_$rep' data-tt-parent-id='signal_trk_pr'><td>" + "fc (rep$rep pr1)"+ "</td><td>"+ _html_link_url( fc_bigwig{"rep$rep"+"_pr1"} ) +"</td></tr>"
			if ( pval_bigwig.hasKey("rep$rep"+"_pr2") ) html += "<tr data-tt-id='signal_trk_pr2_$rep' data-tt-parent-id='signal_trk_pr'><td>" + "pval (rep$rep pr2)"+ "</td><td>"+ _html_link_url( pval_bigwig{"rep$rep"+"_pr2"} ) +"</td></tr>"
			if ( fc_bigwig.hasKey("rep$rep"+"_pr2") ) html += "<tr data-tt-id='signal_trk_pr2_$rep' data-tt-parent-id='signal_trk_pr'><td>" + "fc (rep$rep pr2)"+ "</td><td>"+ _html_link_url( fc_bigwig{"rep$rep"+"_pr2"} ) +"</td></tr>"
		}

		pooled_dir := "$out_dir/pooled_replicate"

		if ( pval_bigwig.hasKey("ppr1") ) {
			html += "<tr data-tt-id='signal_trk_ppr' data-tt-parent-id='signal'><td>" + "Pooled pseudo replicates"+ "</td><td>"+ _html_link_url( pooled_dir ) +"</td></tr>"
			html += "<tr data-tt-id='signal_trk_ppr1' data-tt-parent-id='signal_trk_ppr'><td>" + "pval (ppr1)"+ "</td><td>"+ _html_link_url( pval_bigwig{"ppr1"} ) +"</td></tr>"
			html += "<tr data-tt-id='signal_trk_ppr1' data-tt-parent-id='signal_trk_ppr'><td>" + "fc (ppr1)"+ "</td><td>"+ _html_link_url( fc_bigwig{"ppr1"} ) +"</td></tr>"
			html += "<tr data-tt-id='signal_trk_ppr2' data-tt-parent-id='signal_trk_ppr'><td>" + "pval (ppr2)"+ "</td><td>"+ _html_link_url( pval_bigwig{"ppr2"} ) +"</td></tr>"
			html += "<tr data-tt-id='signal_trk_ppr2' data-tt-parent-id='signal_trk_ppr'><td>" + "fc (ppr2)"+ "</td><td>"+ _html_link_url( fc_bigwig{"ppr2"} ) +"</td></tr>"
		}
	}

	// peaks

	if ( peaks.hasKey("1") ) { // if peak output exists

		html += "<tr data-tt-id='peak'><td>" + "Peaks"+ "</td><td></td></tr>"

		// true rep
		html += "<tr data-tt-id='peak_truerep' data-tt-parent-id='peak'><td>" + "True replicates"+ "</td><td></td></tr>"

		for ( int rep=1; rep <= get_num_rep(); rep++) {

			if ( peaks.hasKey("$rep") ) html += "<tr data-tt-id='peak_$rep' data-tt-parent-id='peak_truerep'><td>" + "rep$rep"+ "</td><td>"+ _html_link_url( peaks{"$rep"} ) +"</td></tr>"
		}

		// pseudo rep
		if ( peaks_pr1.hasKey("1") ) \
			html += "<tr data-tt-id='peak_pr' data-tt-parent-id='peak'><td>" + "Pseudo replicates"+ "</td><td></td></tr>"

		for ( int rep=1; rep <= get_num_rep(); rep++) {
			if ( peaks_pr1.hasKey("$rep") ) html += "<tr data-tt-id='peak_pr1_$rep' data-tt-parent-id='peak_pr'><td>" + "rep$rep pr1"+ "</td><td>"+ _html_link_url( peaks_pr1{"$rep"} ) +"</td></tr>"
			if ( peaks_pr2.hasKey("$rep") ) html += "<tr data-tt-id='peak_pr2_$rep' data-tt-parent-id='peak_pr'><td>" + "rep$rep pr2"+ "</td><td>"+ _html_link_url( peaks_pr2{"$rep"} ) +"</td></tr>"
		}

		pooled_dir := "$out_dir/pooled_replicate"

		if ( peak_ppr1 != "" ) {
			html += "<tr data-tt-id='peak_ppr' data-tt-parent-id='peak'><td>" + "Pooled pseudo replicates"+ "</td><td>"+ _html_link_url( pooled_dir ) +"</td></tr>"

			html += "<tr data-tt-id='peak_ppr1' data-tt-parent-id='peak_ppr'><td>" + "ppr1"+ "</td><td>"+ _html_link_url( peak_ppr1 ) +"</td></tr>"
			html += "<tr data-tt-id='peak_ppr2' data-tt-parent-id='peak_ppr'><td>" + "ppr2"+ "</td><td>"+ _html_link_url( peak_ppr2 ) +"</td></tr>"
		}

		if ( peak_overlap != "" ) {
			html += "<tr data-tt-id='peak_overlap' data-tt-parent-id='peak'><td>" + "Naive overlap"+ "</td><td>"+ _html_link_url( peak_overlap ) +"</td></tr>"
		}
	}

	// idr

	if ( idr_tr != "" ) { // if idr output exists

		string idr_out_dir

		idr_out_dir = "$out_dir/idr2"

		html += "<tr data-tt-id='idr'><td>" + "IDR peaks"+ "</td><td>"+ _html_link_url( idr_out_dir ) +"</td></tr>"

 		if ( idr_tr!="" ) html += "<tr data-tt-id='idr_tr' data-tt-parent-id='idr'><td>" + "True replicates"+ "</td><td>"+ _html_link_url( idr_tr ) +"</td></tr>"
		if ( idr_pr_rep1!="" ) html += "<tr data-tt-id='idr_pr_rep1' data-tt-parent-id='idr'><td>" + "Pseudo-replicates (rep1)"+ "</td><td>"+ _html_link_url( idr_pr_rep1 ) +"</td></tr>"
		if ( idr_pr_rep2!="" ) html += "<tr data-tt-id='idr_pr_rep2' data-tt-parent-id='idr'><td>" + "Pseudo-replicates (rep2)"+ "</td><td>"+ _html_link_url( idr_pr_rep2 ) +"</td></tr>"
		if ( idr_ppr!="" ) html += "<tr data-tt-id='idr_ppr' data-tt-parent-id='idr'><td>" + "Pooled pseudo-replicates"+ "</td><td>"+ _html_link_url( idr_ppr ) +"</td></tr>"
		if ( idr_opt!="" ) html += "<tr data-tt-id='idr_opt' data-tt-parent-id='idr'><td>" + "Optimal set"+ "</td><td>"+ _html_link_url( idr_opt ) +"</td></tr>"
		if ( idr_consv!="" ) html += "<tr data-tt-id='idr_consv' data-tt-parent-id='idr'><td>" + "Conservative set"+ "</td><td>"+ _html_link_url( idr_consv ) +"</td></tr>"
	}

	html += "</tbody></table>"
	html += "</div><br>\n"

	return html
}

string _html_atac_QC() {

	string[] align_qcs, dup_qcs, flagstat_nodup_qcs, pbc_qcs, xcor_qcs, xcor_plots
	string[] align_headers, dup_headers, flagstat_nodup_headers, pbc_headers, xcor_headers

	for ( int rep=1; rep <= get_num_rep(); rep++) {

		info := "rep$rep"
		key := "$rep"

		//html_rep_by_id += _html_xcor( info, 	[ info ], [ xcor_qc{key} ], [ xcor_plot{key} ], [ info ] )

		if ( xcor_qc.hasKey( key ) )	{
			xcor_qcs 		+= xcor_qc{key}
			xcor_plots 		+= xcor_plot{key}
			xcor_headers 		+= info
		}

		if ( align_log.hasKey( key ) ) 		align_qcs 		+= align_log{key}
		if ( dup_qc.hasKey( key ) ) 		dup_qcs 		+= dup_qc{key}
		if ( flagstat_nodup_qc.hasKey( key ) )	flagstat_nodup_qcs 	+= flagstat_nodup_qc{key}
		if ( pbc_qc.hasKey( key ) ) 		pbc_qcs			+= pbc_qc{key}

		if ( align_log.hasKey( key ) ) 		align_headers 		+= info
		if ( dup_qc.hasKey( key ) ) 		dup_headers 		+= info
		if ( flagstat_nodup_qc.hasKey( key ) )	flagstat_nodup_headers 	+= info
		if ( pbc_qc.hasKey( key ) ) 		pbc_headers		+= info

	}

	html := "<div id='atac_qc'>"

	html += _parse_align_log_to_html( "all", 	align_headers, align_qcs, align_headers )
	html += _parse_dup_to_html( "all", 		dup_headers, dup_qcs, dup_headers )
	html += _parse_flagstat_to_html( "all, filtered",flagstat_nodup_headers, flagstat_nodup_qcs, flagstat_nodup_headers )
	html += _parse_pbc_to_html( "all", 		pbc_headers, pbc_qcs, pbc_headers )
	html += _parse_xcor_to_html( "all", 		xcor_headers, xcor_qcs, xcor_plots, xcor_headers )

	// if idr qc's exists, add them to html

	if ( idr_qc != "" ) html += _parse_idr_to_html( "idr", idr_qc )

	if ( idr_tr_png != "" ) html += _html_img( idr_tr_png, 800, "Nt" ) + "&nbsp"
	if ( idr_pr_rep1_png != "" ) html += _html_img( idr_pr_rep1_png, 800, "N1" ) + "&nbsp"
	if ( idr_pr_rep2_png != "" ) html += _html_img( idr_pr_rep2_png, 800, "N2" ) + "&nbsp"
	if ( idr_ppr_png != "" ) html += _html_img( idr_ppr_png, 800, "Np" ) + "&nbsp"

	html += "</div><br>"
	return html
}

string _html_atac_tracks() {

	string[] track_files, track_types, track_names

	if ( pval_bigwig.hasKey( "pooled" ) ) { track_types += "bigwig"; track_names += "pval (pooled)"; track_files += pval_bigwig{"pooled"} }
	if ( fc_bigwig.hasKey( "pooled" ) )   { track_types += "bigwig"; track_names += "fc (pooled)";   track_files += fc_bigwig{"pooled"}   }

	if ( peak_overlap != "" ) { track_types += "hammock"; track_names += "peak overlap"; track_files += _peak_to_hammock( peak_overlap ) }

	if ( idr_opt != "" ) {	track_types += "hammock"; track_names += "peak idr (opt. set)"; track_files += _peak_to_hammock( idr_opt ) }
	if ( idr_consv != "" ) {track_types += "hammock"; track_names += "peak idr (cons. set)"; track_files += _peak_to_hammock( idr_consv ) }

	for (int rep=1; rep<=get_num_rep(); rep++) {

		if ( pval_bigwig.hasKey( "$rep" ) ) { track_types += "bigwig"; track_names += "pval (rep$rep)"; track_files += pval_bigwig{rep} }
		if ( fc_bigwig.hasKey( "$rep" ) )   { track_types += "bigwig"; track_names += "fc (rep$rep)";   track_files += fc_bigwig{rep}   }
		if ( rep==1 && idr_pr_rep1 != "" ) {	track_types += "hammock"; track_names += "peak idr (rep1_pr)"; track_files += _peak_to_hammock( idr_pr_rep1 ) }
		if ( rep==2 && idr_pr_rep2 != "" ) {	track_types += "hammock"; track_names += "peak idr (rep2_pr)"; track_files += _peak_to_hammock( idr_pr_rep2 ) }
	}

	html := _html_epg_browser_viz( track_files, track_types, track_names )

	return html
}

/*
// outputs (pdf, png, log, ...) and report must be in the same directory
string[] _report_atac( string o_dir, string info ) {

	prefix 	 := "$o_dir/report"
	tex_file := "$prefix.tex"
	pdf_file := "$prefix.pdf"

	in 	:= "" // always run this function (don't check file time stamp)
	out 	:= [tex_file, pdf_file]

	taskName:= "report_atac "+info

	task( out<-in ) {

		sys $shcmd_init

		sys cd $o_dir
		sys thisFolder=$o_dir

		//# figure out what we've aligned to
		sys MODEL=$bwt_idx

		//# insert size histogram graph file name
		sys insertSizeHist="$(echo *.hist_graph.pdf)"

		//# PRESEQ graph file name
		sys preseqGraph="$(echo *.preseq.pdf)"

		//# bowtie2 alignment log file name
		sys if [[ $input == "fastq" ]]; then \
			alignLog="$(echo *.align.log)"; \
			alignLogLastLine=$(tail -n 1 ${alignLog}); \
			fi

		//# preseq log file name
		sys preseqLog="$(echo *.preseq.log)"

		//# V-Plot graph file name
		sys vPlot="$(echo *.vect.png)"

		//# Picard duplicate log file name
		sys if [[ $input == "fastq" ]]; then \
			dupQCFile=$(echo *.dup.qc); \
			dupQCHeadings=$(sed -n 7p ${dupQCFile}); \
			dupQCHeadings=${dupQCHeadings//_/\\\\_}; \
			IFS=$'\t' read -a dupQCHeadings <<< "${dupQCHeadings}"; \
			dupQCData=$(sed -n 8p ${dupQCFile}); \
			IFS=$'\t' read -a dupQCData <<< "${dupQCData}"; \
			START=0; \
			END=${#dupQCHeadings[@]}; \
			DUPTABLE=""; \
			for (( c=${START}; c<${END}; c++ )) do \
				if [ "${c}" = "$((END-1))" ]; then \
					DUPTABLE="${DUPTABLE}${dupQCHeadings[${c}]}& ${dupQCData[${c}]} \\\\ \bottomrule"; \
				else \
					DUPTABLE="${DUPTABLE}${dupQCHeadings[${c}]}& ${dupQCData[${c}]} \\\\ \midrule "; \
				fi \
			done; \
			bpcQCFile=$(echo *.pbc.qc); \
			declare -a bpcLabels=("TotalReadPairs" "DistinctReadPairs" "OneReadPair" "TwoReadPairs" "NRF=Distinct/Total" "PBC1=OnePair/Distinct" "PBC2=OnePair/TwoPair"); \
			bpcQC=$(cat ${bpcQCFile}); \
			IFS=$'\t' read -a bpcData <<< "${bpcQC}"; \
			START=0; \
			END=${#bpcLabels[@]}; \
			BPCTABLE=""; \
			for (( c=${START}; c<${END}; c++ )) do \
				if [ "${c}" = "$((END-1))" ]; then \
					BPCTABLE="${BPCTABLE}${bpcLabels[${c}]}& ${bpcData[${c}]} \\\\ \bottomrule"; \
				else \
					BPCTABLE="${BPCTABLE}${bpcLabels[${c}]}& ${bpcData[${c}]} \\\\ \midrule "; \
				fi \
			done; \
			fi

		//# Now we generate the tex language file that defines the report
		//# warning! two layers of command interpretaion in here (bash&tex),
		//# not for the faint of heart!
		sys echo "\documentclass{article}" > $tex_file
		sys echo "\usepackage{graphicx}" >> $tex_file
		sys echo "\usepackage{multicol}" >> $tex_file
		sys echo "\usepackage{listings}" >> $tex_file
		sys echo "\usepackage{grffile}" >> $tex_file
		sys echo "\usepackage[margin=0.5in]{geometry}" >> $tex_file
		sys echo "\usepackage{booktabs}" >> $tex_file
		sys echo "\usepackage{hyphenat}" >> $tex_file
		sys echo "\usepackage{fancyhdr}" >> $tex_file
		sys echo "\pagestyle{fancy}" >> $tex_file
		sys echo "\fancyhf{}" >> $tex_file
		sys echo "\renewcommand{\headrulewidth}{0pt}" >> $tex_file
		sys echo "\fancyfoot[RO, LE] {Generated on $(date)}" >> $tex_file
		sys echo "\begin{document}" >> $tex_file
		sys echo "\setlength{\columnseprule}{0.1pt}" >> $tex_file
		sys echo "\section{Summary for ${thisFolder//_/\\_}}" >> $tex_file
		sys echo "\begin{multicols}{2}" >> $tex_file
		sys echo "\subsection{Genome Model}" >> $tex_file
		sys echo "${MODEL//_/\\_}" >> $tex_file

		sys if [[ ${vPlot} != "*"* ]]; then \
			echo "\subsection{V-Plot}" >> $tex_file; \
			echo "From ${vPlot//_/\\_}:\\\\" >> $tex_file; \
			echo "\includegraphics[width=0.5\textwidth]{${vPlot}}" >> $tex_file; \
			fi

		sys if [[ ${preseqGraph} != "*"* ]]; then \
			echo "\subsection{preseq lc\_extrap Yield Predicion}" >> $tex_file; \
			echo "From ${preseqGraph//_/\\_}:\\\\" >> $tex_file; \
			echo "\includegraphics[width=0.5\textwidth]{${preseqGraph}}" >> $tex_file; \
			fi

		//if [[ $preseqLog != "*"* ]];

		sys if [[ $input == "fastq" ]]; then \
			echo "\subsection{Library Complexity}" >> $tex_file; \
			echo "From ${bpcQCFile//_/\\_}:\\\\" >> $tex_file; \
			echo "\centerline{" >> $tex_file; \
			echo "\begin{tabular}{l|c}" >> $tex_file; \
			echo "\toprule" >> $tex_file; \
			echo "${BPCTABLE}" >> $tex_file; \
			echo "\end{tabular}" >> $tex_file; \
			echo "}" >> $tex_file; \
			if [[ ${insertSizeHist} != "*"* ]]; then \
				echo "\subsection{Insert size histogram}" >> $tex_file; \
				echo "From ${insertSizeHist//_/\\_}:\\\\" >> $tex_file; \
				echo "\includegraphics[width=0.5\textwidth]{${insertSizeHist}}" >> $tex_file; \
				fi; \
			echo "\subsection{Picard Duplication Metrics}" >> $tex_file; \
			echo "From ${dupQCFile//_/\\_}:\\\\" >> $tex_file; \
			echo "\begin{tabular}{l|c}" >> $tex_file; \
			echo "\toprule" >> $tex_file; \
			echo "${DUPTABLE}" >> $tex_file; \
			echo "\end{tabular}" >> $tex_file; \
			echo "\subsection{bowtie2 Alignment Log}" >> $tex_file; \
			echo "\textbf{${alignLogLastLine//'%'/'\%'}}\\\\" >> $tex_file; \
			echo "From ${alignLog//_/\\_}:\\\\" >> $tex_file; \
			echo "\scalebox{.6}{" >> $tex_file; \
			echo "\lstinputlisting{${alignLog}}" >> $tex_file; \
			echo "}" >> $tex_file; \
			fi

		sys echo "\end{multicols}  " >> $tex_file
		sys echo "%\pagebreak" >> $tex_file
		sys echo "\end{document}" >> $tex_file

		//# now generate the pdf report (appears as *.report.pdf)
		//sys cd $o_dir
		sys pdflatex $tex_file
	}

	return out
}
*/

void help() {

	if ( is_cmd_line_arg_empty() ) {

		printHelp()
		exit
	}
}

bool is_input_legacy() {

	bool ret

	if ( args.size() >= 8 ) {
		ret = true

		for (int i=0; i<8;i++) {

			if ( args[i].startsWith("-") ) {
				ret = false
				break
			}
		}
	}

	return ret
}

bool is_input_fastq() {

	return input.toLower() == "fastq"
}

bool is_input_bam() {

	return input.toLower() == "bam"
}

bool is_input_filt_bam() {

	return input.toLower() == "filt_bam"
}

int get_num_rep() {

	if ( is_input_legacy() ) {
		return 1
	}
	else if ( is_input_fastq() ) {

		if ( get_num_rep_fastq()==2 ) {

			fastqs := get_fastqs( 0, 1 )

			if ( !se && fastqs.size()<2 ) return 1
		}

		return get_num_rep_fastq()
	}
	else if ( is_input_bam() )  	return get_num_rep_bam()
	else if ( is_input_filt_bam() ) return get_num_rep_filt_bam()

	return 0
}
