#!/usr/bin/env bds

include "pipeline.bds"

///////////// command line argument wrapper ////////////////

// input file type
string input 		= "fastq"			help Input file type: two options (fastq: including mapping of fastqs, tagalign)

// for fastqs (SE)
string fastq1 		= "" 				help Path for fastq for replicate 1 (single ended).
string fastq2 		= "" 				help Path for fastq for replicate 2 (single ended).
string ctl_fastq1 	= "" 				help Path for control fastq for replicate 1 (single ended).
string ctl_fastq2 	= "" 				help Path for control fastq for replicate 2 (single ended, if not exists leave this blank).

// for fasqts (PE)
string fastq1_1		= "" 				help Path for fastq for replicate 1 pair 1 (paired-end).
string fastq1_2		= "" 				help Path for fastq for replicate 1 pair 2 (paired-end).
string fastq2_1 	= "" 				help Path for fastq for replicate 2 pair 1 (paired-end).
string fastq2_2 	= "" 				help Path for fastq for replicate 2 pair 2 (paired-end).
string ctl_fastq1_1	= "" 				help Path for control fastq for replicate 1 pair 1 (paired-end).
string ctl_fastq1_2	= "" 				help Path for control fastq for replicate 1 pair 2 (paired-end).
string ctl_fastq2_1 	= "" 				help Path for control fastq for replicate 2 pair 1 (paired-end, if not exists leave this blank).
string ctl_fastq2_2 	= "" 				help Path for control fastq for replicate 2 pair 2 (paired-end, if not exists leave this blank).

// for tagalign data set
bool tagalign_PE 	= false 			help Set it true if tagaligns are paired end (default: false).
string tagalign1 	= ""				help Path for tagAlign for replicate 1.
string tagalign2 	= ""				help Path for tagAlign for replicate 2.
string ctl_tagalign1 	= "" 				help Path for control tagAlign for replicate 1.
string ctl_tagalign2 	= "" 				help Path for control tagAlign for replicate 2 (if not exists leave this blank).

string idx_bwa 		= ""				help Path for bwa index.
string param_bwa	= "-q 5 -l 32 -k 2" 		help Parameters for bwa align (default: "-q 5 -l 32 -k 2").

int nth_bwa_aln		= 2 				help Number of threads for bwa aln (default: 2).
int wt_bwa_aln		= 36000				help Walltime in seconds for bwa aln (default: 36000).
int mem_bwa_aln		= 8000	 			help Max. memory in MB for bwa aln (default: 8000).

int wt_bwa_sam		= 36000				help Walltime in seconds for bwa sampe/samse (default: 36000).
int mem_bwa_sam		= 8000 				help Max. memory in MB for bwa sampe/samse (default: 8000).

// signal track generation
bool wig 		= false				help Set it true to create wig (default: false).
bool bedgraph 		= false				help Set it true to create bedgraph (default: false).
bool bigwig 		= false				help Set it true to convert bedgraph to bigwig signal track (default: false).
string umap 		= "" 				help Path for umap (for hg19, path for globalmap_k20tok54).
string seq 		= "" 				help Path for sequence files (for hg19, directory where chr*.fa exist).
string chrsz 		= "" 				help Path for chrom.sizes file for your sequence files.

int mapq_thresh 	= 30 				help MAPQ_THRESH (default: 30).
int nreads 		= 15000000			help NREADS (default. 15000000).

bool qc 		= false 			help Set it true to test-run and stop before peak calling, false: keep going through IDR (default: false).
int num_rep 		= 2				help Number of replicates, define it for qc = true only. (default: 2).
//int fraglen 		= 200  				//help FragLen for tagAlign input


///////////// actual parameter variables ////////////////

string INPUT_TYPE 	= input
bool TAGALIGN_PE 	= tagalign_PE
string BWA_INDEX_NAME	= idx_bwa		
string BWA_ALN_PARAM 	= param_bwa
int NTHREADS_BWA_ALN 	= nth_bwa_aln
int WALLTIME_BWA_ALN 	= wt_bwa_aln
int MEMORY_BWA_ALN	= mem_bwa_aln
int WALLTIME_BWA_SAM 	= wt_bwa_sam
int MEMORY_BWA_SAM	= mem_bwa_sam
bool CREATE_WIG 	= wig
bool CREATE_BEDGRAPH 	= bedgraph
bool CONVERT_TO_BIGWIG 	= bigwig
string UMAP_DIR 	= umap
string SEQ_DIR 		= seq	
string CHROM_SIZES 	= chrsz
int MAPQ_THRESH 	= mapq_thresh
int NREADS 		= nreads
bool QC_ONLY		= qc
int NUM_REP 		= num_rep
//int FRAGLEN 		= fraglen

// system vars
int NUM_CTL

// program body
init_cmd_line_arg_fastqs()


void read_param_align_map() {

	if ( conf_file_exists() ) { // parameters in conf_file overrides those on cmd line args.

		if ( conf.hasKey("INPUT_TYPE") )	INPUT_TYPE		= rm_comment( conf{ "INPUT_TYPE"} )
		if ( conf.hasKey("TAGALIGN_PE") )	TAGALIGN_PE 		= parse_bool( conf{ "TAGALIGN_PE"} )
		if ( conf.hasKey("BWA_INDEX_NAME") )	BWA_INDEX_NAME 		= chk_file( conf{ "BWA_INDEX_NAME" }, ".bwt" ) // check if filename+".bwt" exists
		if ( conf.hasKey("BWA_ALN_PARAM") )	BWA_ALN_PARAM 		= rm_comment( conf{ "BWA_ALN_PARAM" } )
		if ( conf.hasKey("NTHREADS_BWA_ALN") )	NTHREADS_BWA_ALN	= parse_int( conf{ "NTHREADS_BWA_ALN" } )
		if ( conf.hasKey("WALLTIME_BWA_ALN") )	WALLTIME_BWA_ALN 	= parse_int( conf{ "WALLTIME_BWA_ALN" } )
		if ( conf.hasKey("MEMORY_BWA_ALN") )	MEMORY_BWA_ALN 		= parse_int( conf{ "MEMORY_BWA_ALN" } )
		if ( conf.hasKey("WALLTIME_BWA_SAM") )	WALLTIME_BWA_SAM 	= parse_int( conf{ "WALLTIME_BWA_SAM" } )
		if ( conf.hasKey("MEMORY_BWA_SAM") )	MEMORY_BWA_SAM 		= parse_int( conf{ "MEMORY_BWA_SAM" } )
		if ( conf.hasKey("CREATE_WIG") )	CREATE_WIG		= parse_bool( conf{ "CREATE_WIG"} )
		if ( conf.hasKey("CREATE_BEDGRAPH") )	CREATE_BEDGRAPH		= parse_bool( conf{ "CREATE_BEDGRAPH"} )
		if ( conf.hasKey("CONVERT_TO_BIGWIG") )	CONVERT_TO_BIGWIG	= parse_bool( conf{ "CONVERT_TO_BIGWIG"} )
		if ( conf.hasKey("CHROM_SIZES") )	CHROM_SIZES 		= chk_file( conf{"CHROM_SIZES"}, "" )
		if ( conf.hasKey("UMAP_DIR") )		UMAP_DIR 		= get_path( conf{"UMAP_DIR"} )
		if ( conf.hasKey("SEQ_DIR") )		SEQ_DIR 		= get_path( conf{"SEQ_DIR"} )
		if ( conf.hasKey("MAPQ_THRESH") )	MAPQ_THRESH 		= parse_int( conf{ "MAPQ_THRESH" } )
		if ( conf.hasKey("NREADS") )		NREADS 			= parse_int( conf{ "NREADS" } )

//		if ( conf.hasKey("FRAGLEN") )		FRAGLEN 		= parse_int( conf{ "FRAGLEN"} )

		// QC only?
		if ( conf.hasKey("QC_ONLY") )		QC_ONLY 		= parse_bool( conf{ "QC_ONLY"} )
		if ( QC_ONLY ) \
			NUM_REP	= parse_int( conf{ "NUM_REP"} )
	}
	else {
	}

	NUM_CTL 	= QC_ONLY ? 0 : 1

	// check params
	if ( BWA_INDEX_NAME == "" ) error("BWA_INDEX_NAME is not specifed.")
	print("INPUT_TYPE = $INPUT_TYPE\n");
	print("BWA_INDEX_NAME = $BWA_INDEX_NAME\n");
	print("BWA_ALN_PARAM = $BWA_ALN_PARAM\n");
	print("NTHREADS_BWA_ALN = $NTHREADS_BWA_ALN\n");
	print("WALLTIME_BWA_ALN = $WALLTIME_BWA_ALN\n");	
	print("MEMORY_BWA_ALN = $MEMORY_BWA_ALN\n");	
	print("WALLTIME_BWA_SAM = $WALLTIME_BWA_SAM\n");	
	print("MEMORY_BWA_SAM = $MEMORY_BWA_SAM\n");	
	print("MAPQ_THRESH = $MAPQ_THRESH\n");
	print("NREADS = $NREADS\n");

	print("QC_ONLY = $QC_ONLY\n");	
	if ( QC_ONLY ) return // if QC only mode, do not check inputs (fastq or tagaligns)

	if ( (CREATE_WIG || CREATE_BEDGRAPH) && (UMAP_DIR == "") ) error("UMAP_DIR is not specifed.")
	if ( (CREATE_WIG || CREATE_BEDGRAPH) && (SEQ_DIR == "") ) error("SEQ_DIR is not specifed.")
	if ( CONVERT_TO_BIGWIG && (CHROM_SIZES == "") ) error("CHROM_SIZES is not specifed.")

	print("CREATE_WIG = $CREATE_WIG\n");
	print("CREATE_BEDGRAPH = $CREATE_BEDGRAPH\n");
	print("CONVERT_TO_BIGWIG = $CONVERT_TO_BIGWIG\n");
	print("CHROM_SIZES = $CHROM_SIZES\n");
	print("UMAP_DIR = $UMAP_DIR\n");
	print("SEQ_DIR = $SEQ_DIR\n");

	if ( is_input_fastq() ) {

		print( "\n====== Checking fastqs...\n" );

		for ( int ctl=0; ctl <= NUM_CTL; ctl++) { // iterate through fastqs (0: not control, 1~: controls)

			prefix := (ctl==0)? "":"Control "
			fastqs_Rep1 := get_fastqs(  ctl, 1 )
			fastqs_Rep2 := get_fastqs(  ctl, 2 )

			print( prefix + "Rep1: \n")
			for ( string s : fastqs_Rep1 ) print("\t$s\n")

			print( prefix + "Rep2: \n")
			for ( string s : fastqs_Rep2 ) print("\t$s\n")
			
			if ( fastqs_Rep1.size() == 0 ) error( prefix + "Rep1 fastqs missing!\n")

			if ( fastqs_Rep2.size() == 0 ) {
				if ( ctl==0 ) {
					error( prefix + "Rep2 fastqs missing!\n")
				}
				else {
					print( "Warning: " + prefix + "Rep2 fastqs missing for control! keep going...\n")
				}
			}
		}
	}

	if ( is_input_tagalign() ) {

		print( "\n====== Checking tagAligns...\n" );

		for ( int ctl=0; ctl <= NUM_CTL; ctl++) { // iterate through fastqs (0: not control, 1~: controls)

			prefix := (ctl==0)? "":"Control "
			tagalign_Rep1 := get_tagalign(  ctl, 1 )
			tagalign_Rep2 := get_tagalign(  ctl, 2 )

			print( prefix + "Rep1: $tagalign_Rep1 \n")
			print( prefix + "Rep2: $tagalign_Rep2 \n")
			
			if ( tagalign_Rep1 == "" ) error( prefix + "Rep1 tagalign missing!\n")

			if ( tagalign_Rep2 == "" ) {
				if ( ctl==0 ) {
					error( prefix + "Rep2 tagalign missing!\n")
				}
				else {
					print( "Warning: " + prefix + "Rep2 tagalign missing for control! keep going...\n")
				}
			}
		}

		print("TAGALIGN_PE = $TAGALIGN_PE\n");
//		print("FRAGLEN = $FRAGLEN\n");
	}

	if ( DIR_SW_BDS.exists() ) { // automatically add software binaries to PATH

		print("\n\nFound BigDataScript pipeline software directory ($DIR_SW_BDS) \n")
		print("Automatically adding environment variables...\n")

		PATH := " export PATH=" \
				+ "$DIR_SW_BDS/bwa-0.7.10:" \
				+ "$DIR_SW_BDS/samtools-0.1.19:" \
				+ "$DIR_SW_BDS/bedtools2-2.19.1/bin:" \
				+ "$DIR_SW_BDS/ucsc_tools:" \
				+ "$DIR_SW_BDS/picard-tools-1.92:" \
				+ "$DIR_SW_BDS/R-2.15.1/bin:" \
				+ "$DIR_SW_BDS/phantompeakqualtools:" \
				+ "$DIR_SW_BDS/idr/bin:" \
				+ "$DIR_SW_BDS/python3.4/bin:" \
				+ "$DIR_SW_BDS/align2rawsignal/bin:" \
				+ "$DIR_SW_BDS/idrCode:" \
				+ "\${PATH}"

		SHELLCMD := "export PICARDROOT=$DIR_SW_BDS/picard-tools-1.92;" \

		SHELLCMD = SHELLCMD \
				+ "MCRROOT=$DIR_SW_BDS/MATLAB_Compiler_Runtime/v714;" \
				+ "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:\${MCRROOT}/runtime/glnxa64;" \
				+ "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:\${MCRROOT}/bin/glnxa64;" \
				+ "MCRJRE=\${MCRROOT}/sys/java/jre/glnxa64/jre/lib/amd64;" \
				+ "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:\${MCRJRE}/native_threads;" \
				+ "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:\${MCRJRE}/server;" \
				+ "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:\${MCRJRE};" \
				+ "XAPPLRESDIR=\${MCRROOT}/X11/app-defaults;" \
				+ "export LD_LIBRARY_PATH;" \
				+ "export XAPPLRESDIR;"

		PRELOAD = PRELOAD + ";" + PATH + ";" + SHELLCMD
		PRELOAD = PRELOAD.replace( ";;", ";" )

	}

	print("\n")
}

void align_to_pspr() {  // this function is for parallel jobs for each control and replicate

	// align -> post_align -> xcor -> self-pseudo-replicate (spr) -> pooled spr
	
	for ( int ctl=0; ctl <= NUM_CTL; ctl++) { // iterate through inputs (ctl==0 : control, ctl==1 : input)
		for ( int rep=1; rep <= NUM_REP; rep++) {
			par align_to_spr( ctl, rep ) 
		}
	}

	wait

	for ( int ctl=0; ctl <= NUM_CTL; ctl++) \
		par pspr( ctl )

	wait
}

void align_to_spr( int ctl, int rep ) {

	if ( is_input_fastq() ) {
		align_bwa( ctl, rep )
		post_align_filt( ctl, rep )
	 	bam_to_tagalign( ctl, rep )
	}
	else if ( is_input_tagalign() ) {
		softlink_tagalign( ctl, rep )
	}

 	xcor( ctl, rep )
 	spr( ctl, rep )
 	sig_trk( ctl, rep )
}

void align_bwa( int ctl, int rep ) {

	print( "\n====== align_bwa ctl:$ctl rep:$rep...\n" );

	OFPREFIX := get_ofprefix( ctl, rep )
	fastqs := get_fastqs( ctl, rep )

	if ( is_paired_end( ctl, rep ) ) {

		FASTQ_FILE_1 	:= fastqs[0]
		FASTQ_FILE_2 	:= fastqs[1]

		SAI_FILE_1 	:= "$OFPREFIX"+"_1.sai"
		SAI_FILE_2 	:= "$OFPREFIX"+"_2.sai"

		RAW_SAM_FILE 	:= "$OFPREFIX.raw.sam.gz"

		RAW_BAM_PREFIX 	:="$OFPREFIX.raw.srt"
		RAW_BAM_FILE 	:= "$RAW_BAM_PREFIX.bam" //# To be stored
		BADCIGAR_FILE 	:= "$TMP_DIR/badReads."+OFPREFIX.baseName()+".tmp"
		RAW_BAM_FILE_MAPSTATS := "$RAW_BAM_PREFIX.flagstat.qc" //# QC File

		// run for outputs
		if( [RAW_BAM_FILE, RAW_BAM_FILE_MAPSTATS] <- [FASTQ_FILE_1, FASTQ_FILE_2]  ) {

			task( taskName := "bwa aln PE1 " + cat_ctl_rep(ctl, rep), \
				cpus := NTHREADS_BWA_ALN, timeout := WALLTIME_BWA_ALN, mem := MEMORY_BWA_ALN * M, \
				SAI_FILE_1 <- FASTQ_FILE_1 ) {

				sys $PRELOAD				

				sys bwa aln $BWA_ALN_PARAM -t $NTHREADS_BWA_ALN $BWA_INDEX_NAME $FASTQ_FILE_1 > $SAI_FILE_1
			}

			task( taskName := "bwa aln PE2 " + cat_ctl_rep(ctl, rep), \
				cpus := NTHREADS_BWA_ALN, timeout := WALLTIME_BWA_ALN, mem := MEMORY_BWA_ALN * M, \
				SAI_FILE_2 <- FASTQ_FILE_2 ) {

				sys $PRELOAD				

				sys bwa aln $BWA_ALN_PARAM -t $NTHREADS_BWA_ALN $BWA_INDEX_NAME $FASTQ_FILE_2 > $SAI_FILE_2
			}

			wait

			task( taskName := "bwa sampe " + cat_ctl_rep(ctl, rep), \
				cpus := NTHREADS, timeout := WALLTIME_BWA_SAM, mem := MEMORY_BWA_SAM * M, \
				RAW_SAM_FILE <- [SAI_FILE_1, SAI_FILE_2] ) {

				sys $PRELOAD				
				
				sys bwa sampe $BWA_INDEX_NAME $SAI_FILE_1 $SAI_FILE_2 $FASTQ_FILE_1 $FASTQ_FILE_2 | \
					gzip -c > $RAW_SAM_FILE
			}

			wait

			task( taskName := "raw bam mapstats " + cat_ctl_rep(ctl, rep), \
				cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
				[RAW_BAM_FILE, RAW_BAM_FILE_MAPSTATS] <- RAW_SAM_FILE ) {

				//# ==============================================================                                         
				//# Remove read pairs with bad CIGAR strings and sort by position                                                                
				//# ==============================================================

				sys $PRELOAD				
			 
				//# Find bad CIGAR read names                                                                                                                                                  
				sys zcat $RAW_SAM_FILE \
					| awk 'BEGIN {FS="\t" ; OFS="\t"} ! /^@/ && $6!="*" { cigar=$6; gsub("[0-9]+D","",cigar); n = split(cigar,vals,"[A-Z]"); s = 0; for (i=1;i<=n;i++) s=s+vals[i]; seqlen=length($10) ; if (s!=seqlen) print $1"\t"; }' \
					| sort | uniq > $BADCIGAR_FILE

				//# Remove bad CIGAR read pairs
				sys if [ $(cat $BADCIGAR_FILE | wc -l) -gt 0 ]; then \
						zcat $RAW_SAM_FILE | grep -v -F -f $BADCIGAR_FILE | samtools view -Su - | samtools sort - $RAW_BAM_PREFIX; \
					else \
						samtools view -Su $RAW_SAM_FILE | samtools sort - $RAW_BAM_PREFIX; \
					fi

				sys samtools flagstat $RAW_BAM_FILE > $RAW_BAM_FILE_MAPSTATS
				sys rm -f $BADCIGAR_FILE $RAW_SAM_FILE
				sys rm -f $SAI_FILE_1 $SAI_FILE_2
			}

			wait
		}

	}
	else if ( is_single_ended( ctl, rep ) ) {

		FASTQ_FILE_1 := fastqs[0]

		SAI_FILE_1 :="$OFPREFIX.sai"
		RAW_BAM_PREFIX :="$OFPREFIX.raw.srt"
		RAW_BAM_FILE :="$RAW_BAM_PREFIX.bam" //# To be stored
		RAW_BAM_FILE_MAPSTATS :="$RAW_BAM_PREFIX.flagstat.qc" //# QC File

		if ( [RAW_BAM_FILE, RAW_BAM_FILE_MAPSTATS] <- FASTQ_FILE_1 ) {

			task( taskName := "bwa aln " + cat_ctl_rep(ctl, rep), \
				cpus := NTHREADS_BWA_ALN, timeout := WALLTIME_BWA_ALN, mem := MEMORY_BWA_ALN * M, \
				SAI_FILE_1 <- FASTQ_FILE_1 ) {

				sys $PRELOAD

				//# ========================================
				//# Map reads to create raw SAM file
				//# ========================================			
				
				sys bwa aln -q 5 -l 32 -k 2 -t $NTHREADS_BWA_ALN $BWA_INDEX_NAME $FASTQ_FILE_1 > $SAI_FILE_1
			}

			wait

			task( taskName := "bwa samse " + cat_ctl_rep(ctl, rep), \
				cpus := NTHREADS, timeout := WALLTIME_BWA_SAM, mem := MEMORY_BWA_SAM * M, \
				RAW_BAM_FILE <- SAI_FILE_1 ) {

				sys $PRELOAD

				sys bwa samse $BWA_INDEX_NAME $SAI_FILE_1 $FASTQ_FILE_1 | \
					samtools view -Su - | samtools sort - $RAW_BAM_PREFIX
			}

			wait

			task( taskName := "raw bam mapstats " + cat_ctl_rep(ctl, rep), \
				cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
				RAW_BAM_FILE_MAPSTATS <- RAW_BAM_FILE ) {

				sys $PRELOAD

				sys samtools flagstat $RAW_BAM_FILE > $RAW_BAM_FILE_MAPSTATS
				sys rm -f $SAI_FILE_1
			}

			wait
		}
		
	}
	else { // no data		
		print("warning(align_bwa): no input for ctl $ctl, rep $rep\n")
	}

}

void post_align_filt( int ctl, int rep ) {

	print( "\n====== post_align_filt ctl:$ctl rep:$rep...\n" );

	OFPREFIX := get_ofprefix( ctl, rep )
	
	if ( is_paired_end( ctl, rep ) ) { // if data is paired-end, therefore PE1 and PE2

		FILT_BAM_PREFIX :="$OFPREFIX.filt.srt"
		FILT_BAM_FILE :="$FILT_BAM_PREFIX.bam"

		TMP_FILT_BAM_PREFIX :="$FILT_BAM_PREFIX.nmsrt.tmp2"
		TMP_FILT_BAM_FILE :="$TMP_FILT_BAM_PREFIX.bam"
		
		TMP_FILT_BAM_FILE2 :="$FILT_BAM_PREFIX.dupmark.bam"
		DUP_FILE_QC :="$FILT_BAM_PREFIX.dup.qc"

		FINAL_BAM_PREFIX :="$OFPREFIX.filt.srt.nodup"
		FINAL_BAM_FILE :="$FINAL_BAM_PREFIX.bam" //# To be stored
		FINAL_BAM_INDEX_FILE :="$FINAL_BAM_PREFIX.bai"
		FINAL_BAM_FILE_MAPSTATS :="$FINAL_BAM_PREFIX.flagstat.qc" //# QC file
		FINAL_NMSRT_BAM_PREFIX :="$OFPREFIX.filt.nmsrt.nodup"
		FINAL_NMSRT_BAM_FILE :="$FINAL_NMSRT_BAM_PREFIX.bam" //# To be stored

		RAW_BAM_PREFIX :="$OFPREFIX.raw.srt"
		RAW_BAM_FILE :="$RAW_BAM_PREFIX.bam" //# To be stored

		PBC_FILE_QC :="$FINAL_BAM_PREFIX.pbc.qc"

		task( taskName := "post_align_filt " + cat_ctl_rep(ctl, rep), \
			cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			[PBC_FILE_QC, FINAL_BAM_INDEX_FILE, FINAL_BAM_FILE_MAPSTATS, FINAL_NMSRT_BAM_FILE, FINAL_BAM_FILE] <- RAW_BAM_FILE ) {

			sys $PRELOAD				

			//# =============================
			//# Remove  unmapped, mate unmapped
			//# not primary alignment, reads failing platform
			//# Remove low MAPQ reads
			//# Only keep properly paired reads
			//# Obtain name sorted BAM file
			//# ==================

			sys samtools view -F 1804 -f 2 -q $MAPQ_THRESH -u $RAW_BAM_FILE | \
				samtools sort -n - $TMP_FILT_BAM_PREFIX       # Will produce name sorted BAM

			//# Remove orphan reads (pair was removed)
			//# and read pairs mapping to different chromosomes
			//# Obtain position sorted BAM			

			//# Will produce coordinate sorted BAM
			// segmentation fault occurred so I split it into two cmd lines 

			//sys samtools fixmate -r $TMP_FILT_BAM_FILE | \
			//	samtools view -F 1804 -f 2 -u - | \
			//	samtools sort - $FILT_BAM_PREFIX			
			sys samtools fixmate -r $TMP_FILT_BAM_FILE $OFPREFIX.fixmate.tmp
			sys samtools view -F 1804 -f 2 -u $OFPREFIX.fixmate.tmp | samtools sort - $FILT_BAM_PREFIX
			sys rm $OFPREFIX.fixmate.tmp

			//# =============
			//# Mark duplicates
			//# =============

			sys java -Xmx4G -jar ${PICARDROOT}/MarkDuplicates.jar \
				INPUT=$FILT_BAM_FILE OUTPUT=$TMP_FILT_BAM_FILE2 \
				METRICS_FILE=$DUP_FILE_QC VALIDATION_STRINGENCY=LENIENT \
				ASSUME_SORTED=true REMOVE_DUPLICATES=false
			
			//# ============================
			//# Remove duplicates
			//# Index final position sorted BAM
			//# Create final name sorted BAM
			//# ============================

			//sys mv $TMP_FILT_BAM_FILE2 $FILT_BAM_FILE
			//sys samtools view -F 1804 -f 2 -b $FILT_BAM_FILE > $FINAL_BAM_FILE
			sys samtools view -F 1804 -f 2 -b $TMP_FILT_BAM_FILE2 > $FINAL_BAM_FILE
							
			sys samtools sort -n $FINAL_BAM_FILE $FINAL_NMSRT_BAM_PREFIX

			sys samtools index $FINAL_BAM_FILE $FINAL_BAM_INDEX_FILE
			sys samtools flagstat $FINAL_BAM_FILE > $FINAL_BAM_FILE_MAPSTATS

			//# =============================
			//# Compute library complexity
			//# =============================
			//# Sort by name
			//# convert to bedPE and obtain fragment coordinates
			//# sort by position and strand
			//# Obtain unique count statistics
		
			//# TotalReadPairs [tab] DistinctReadPairs [tab] OneReadPair [tab] TwoReadPairs [tab] NRF=Distinct/Total [tab] PBC1=OnePair/Distinct [tab] PBC2=OnePair/TwoPair

			// segmentation fault occurred so I split it into two cmd lines 

			//sys samtools sort -n $FILT_BAM_FILE | \
			//	bedtools bamtobed -bedpe -i stdin | \
			//	awk 'BEGIN{OFS="\t"}{print $1,$2,$4,$6,$9,$10}' | \
			//	grep -v 'chrM' | sort | uniq -c | \
			//	awk 'BEGIN{mt=0;m0=0;m1=0;m2=0} ($1==1){m1=m1+1} ($1==2){m2=m2+1} {m0=m0+1} {mt=mt+$1} END{printf "%d\t%d\t%d\t%d\t%f\t%f\t%f\n",mt,m0,m1,m2,m0/mt,m1/m0,m1/m2}' > $PBC_FILE_QC
			
			sys samtools sort -n $TMP_FILT_BAM_FILE2 $OFPREFIX.srt.tmp
			sys bedtools bamtobed -bedpe -i $OFPREFIX.srt.tmp.bam | \
				awk 'BEGIN{OFS="\t"}{print $1,$2,$4,$6,$9,$10}' | \
				grep -v 'chrM' | sort | uniq -c | \
				awk 'BEGIN{mt=0;m0=0;m1=0;m2=0} ($1==1){m1=m1+1} ($1==2){m2=m2+1} {m0=m0+1} {mt=mt+$1} END{printf "%d\t%d\t%d\t%d\t%f\t%f\t%f\n",mt,m0,m1,m2,m0/mt,m1/m0,m1/m2}' > $PBC_FILE_QC
			sys rm $OFPREFIX.srt.tmp.bam
			
			sys rm -f $FILT_BAM_FILE
			sys rm -f $TMP_FILT_BAM_FILE
			sys rm -f $TMP_FILT_BAM_FILE2
		}

		wait
	}
	else if ( is_single_ended( ctl, rep ) ) {

		RAW_BAM_PREFIX 	:="$OFPREFIX.raw.srt"
		RAW_BAM_FILE 	:="$RAW_BAM_PREFIX.bam"

		FILT_BAM_PREFIX :="$OFPREFIX.filt.srt"
		FILT_BAM_FILE 	:="$FILT_BAM_PREFIX.bam"

		TMP_FILT_BAM_FILE 	:="$FILT_BAM_PREFIX.dupmark.bam"
		DUP_FILE_QC 		:="$FILT_BAM_PREFIX.dup.qc" //# QC file

		FINAL_BAM_PREFIX 	:="$OFPREFIX.filt.nodup.srt"
		FINAL_BAM_FILE 		:="$FINAL_BAM_PREFIX.bam" //# To be stored
		FINAL_BAM_INDEX_FILE 	:="$FINAL_BAM_PREFIX.bai" //# To be stored
		FINAL_BAM_FILE_MAPSTATS :="$FINAL_BAM_PREFIX.flagstat.qc" //# QC file
		PBC_FILE_QC 		:="$FINAL_BAM_PREFIX.pbc.qc"

		task( taskName := "post_align_filt " + cat_ctl_rep(ctl, rep), \
			cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			[PBC_FILE_QC, FINAL_BAM_INDEX_FILE, FINAL_BAM_FILE_MAPSTATS, FINAL_BAM_FILE] <- RAW_BAM_FILE ) {

			sys $PRELOAD

			//# =============================
			//# Remove  unmapped, mate unmapped
			//# not primary alignment, reads failing platform
			//# Remove low MAPQ reads
			//# ==================  
			sys samtools view -F 1804 -q $MAPQ_THRESH -b $RAW_BAM_FILE > $FILT_BAM_FILE

			//# ========================
			//# Mark duplicates
			//# ======================
			sys java -Xmx4G -jar ${PICARDROOT}/MarkDuplicates.jar \
				INPUT=$FILT_BAM_FILE OUTPUT=$TMP_FILT_BAM_FILE \
				METRICS_FILE=$DUP_FILE_QC VALIDATION_STRINGENCY=LENIENT \
				ASSUME_SORTED=true REMOVE_DUPLICATES=false
			//sys mv $TMP_FILT_BAM_FILE $FILT_BAM_FILE

			//# ============================
			//# Remove duplicates
			//# Index final position sorted BAM
			//# ============================
			//sys samtools view -F 1804 -b $FILT_BAM_FILE > $FINAL_BAM_FILE
			sys samtools view -F 1804 -b $TMP_FILT_BAM_FILE > $FINAL_BAM_FILE
			
			//# Index Final BAM file
			sys samtools index $FINAL_BAM_FILE $FINAL_BAM_INDEX_FILE
			sys samtools flagstat $FINAL_BAM_FILE > $FINAL_BAM_FILE_MAPSTATS

			//# =============================
			//# Compute library complexity
			//# =============================
			//# sort by position and strand
			//# Obtain unique count statistics

			//# PBC File output
			//# TotalReadPairs [tab] DistinctReadPairs [tab] OneReadPair [tab] TwoReadPairs [tab] NRF=Distinct/Total [tab] PBC1=OnePair/Distinct [tab] PBC2=OnePair/TwoPair

			//sys bedtools bamtobed -i $FILT_BAM_FILE | \
			sys bedtools bamtobed -i $TMP_FILT_BAM_FILE | \
				awk 'BEGIN{OFS="\t"}{print $1,$2,$3,$6}' | \
				grep -v 'chrM' | sort | uniq -c | \
				awk 'BEGIN{mt=0;m0=0;m1=0;m2=0} ($1==1){m1=m1+1} ($1==2){m2=m2+1} {m0=m0+1} {mt=mt+$1} END{printf "%d\t%d\t%d\t%d\t%f\t%f\t%f\n",mt,m0,m1,m2,m0/mt,m1/m0,m1/m2}' > $PBC_FILE_QC

			sys rm -r $FILT_BAM_FILE
			sys rm -r $TMP_FILT_BAM_FILE
		}
		wait
	}
	else { // no data		
		print("warning(post_align_filt): no input for ctl $ctl, rep $rep\n")
	}

}

void bam_to_tagalign( int ctl, int rep ) {

	print( "\n====== bam_to_tagalign ctl:$ctl rep:$rep...\n" );

	OFPREFIX := get_ofprefix( ctl, rep )
	NREADS_PER_MILLION := NREADS/1000000

	if ( is_paired_end( ctl, rep ) ) {

	 	FINAL_BAM_PREFIX 	:="$OFPREFIX.filt.srt.nodup"
		FINAL_BAM_FILE 		:="$FINAL_BAM_PREFIX.bam"
		FINAL_TA_FILE 		:="$FINAL_BAM_PREFIX.PE2SE.tagAlign.gz"
		FINAL_NMSRT_BAM_PREFIX 	:="$OFPREFIX.filt.nmsrt.nodup"
		FINAL_NMSRT_BAM_FILE 	:="$FINAL_NMSRT_BAM_PREFIX.bam" //# To be stored

		FINAL_BEDPE_FILE 	:="$FINAL_NMSRT_BAM_PREFIX.bedpe.gz"
		SUBSAMPLED_TA_FILE 	:="$OFPREFIX.filt.nodup.sample.$NREADS_PER_MILLION.MATE1.tagAlign.gz"

		task( taskName := "bam_to_tagAlign " + cat_ctl_rep(ctl, rep), \
			cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			[FINAL_TA_FILE, FINAL_BEDPE_FILE, SUBSAMPLED_TA_FILE] <- [FINAL_BAM_FILE, FINAL_NMSRT_BAM_FILE] ) {

			sys $PRELOAD

			//# ===================
			//# Create tagAlign file
			//# ===================			
			sys bedtools bamtobed -i $FINAL_BAM_FILE | awk 'BEGIN{OFS="\t"}{$4="N";$5="1000";print $0}' | gzip -c > $FINAL_TA_FILE			
			
			//# ================
			//# Create BEDPE file
			//# ================
			sys bedtools bamtobed -bedpe -mate1 -i $FINAL_NMSRT_BAM_FILE | gzip -c > $FINAL_BEDPE_FILE

			//# =================================
			//# Subsample tagAlign file
			//# Restrict to one read end per pair for CC analysis
			//# ================================
			sys zcat $FINAL_BEDPE_FILE | \
				grep -v "chrM" | shuf -n $NREADS | \
				awk 'BEGIN{OFS="\t"}{print $1,$2,$3,"N","1000",$9}' | gzip -c > $SUBSAMPLED_TA_FILE
		}

		wait

	}
	else if ( is_single_ended( ctl, rep ) ) { 

		FINAL_BAM_PREFIX 	:="$OFPREFIX.filt.nodup.srt"
		FINAL_BAM_FILE 		:="$FINAL_BAM_PREFIX.bam" //# To be stored
		FINAL_TA_FILE 		:="$FINAL_BAM_PREFIX.SE.tagAlign.gz"
		SUBSAMPLED_TA_FILE 	:="$OFPREFIX.filt.nodup.sample.$NREADS_PER_MILLION.SE.tagAlign.gz"

		task( taskName := "make tagAlign " + cat_ctl_rep(ctl, rep), \
			cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			[FINAL_TA_FILE, SUBSAMPLED_TA_FILE] <- FINAL_BAM_FILE ) { 

			sys $PRELOAD
		
			//# ===================
			//# Create tagAlign file
			//# ===================

			//# Create SE tagAlign file
			
			sys bedtools bamtobed -i $FINAL_BAM_FILE | \
				awk 'BEGIN{OFS="\t"}{$4="N";$5="1000";print $0}' | gzip -c > $FINAL_TA_FILE

			//# =================================
			//# Subsample tagAlign file
			//# ================================
			sys zcat $FINAL_TA_FILE | \
				grep -v "chrM" | shuf -n $NREADS | gzip -c > $SUBSAMPLED_TA_FILE
		}

		wait

	}
	else { // no data		
		print("warning(bam_to_tagAlign): no input for ctl $ctl, rep $rep\n")
	}
}

void softlink_tagalign( int ctl, int rep ) {

	print( "\n====== softlink_tagalign ctl:$ctl rep:$rep...\n" );

	OFPREFIX := get_ofprefix( ctl, rep )
	NREADS_PER_MILLION := NREADS/1000000

	tagalign := get_tagalign( ctl, rep )

	if ( is_paired_end( ctl, rep ) ) {

	 	FINAL_BAM_PREFIX 	:="$OFPREFIX.filt.srt.nodup"
		FINAL_TA_FILE 		:="$FINAL_BAM_PREFIX.PE2SE.tagAlign.gz"
		FINAL_NMSRT_BAM_PREFIX 	:="$OFPREFIX.filt.nmsrt.nodup"
		FINAL_NMSRT_BAM_FILE 	:="$FINAL_NMSRT_BAM_PREFIX.bam" //# To be stored

		FINAL_BEDPE_FILE 	:="$FINAL_NMSRT_BAM_PREFIX.bedpe.gz"
		SUBSAMPLED_TA_FILE 	:="$OFPREFIX.filt.nodup.sample.$NREADS_PER_MILLION.MATE1.tagAlign.gz"

		task( taskName := "softlink_tagalign " + cat_ctl_rep(ctl, rep), \
			cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			[FINAL_BEDPE_FILE, SUBSAMPLED_TA_FILE] <- tagalign ) {

			sys $PRELOAD

			//# ===================
			//# Create tagAlign file
			//# ===================			
			sys ln -f -s $tagalign $FINAL_TA_FILE
		
			//# ================
			//# Create BEDPE file
			//# ================
			sys bedtools bamtobed -bedpe -mate1 -i $FINAL_NMSRT_BAM_FILE | gzip -c > $FINAL_BEDPE_FILE

			//# =================================
			//# Subsample tagAlign file
			//# Restrict to one read end per pair for CC analysis
			//# ================================
			sys zcat $FINAL_BEDPE_FILE | \
				grep -v "chrM" | shuf -n $NREADS | \
				awk 'BEGIN{OFS="\t"}{print $1,$2,$3,"N","1000",$9}' | gzip -c > $SUBSAMPLED_TA_FILE
		}

		wait
	}
	else if ( is_single_ended( ctl, rep ) ) { 

		FINAL_BAM_PREFIX 	:="$OFPREFIX.filt.nodup.srt"
		FINAL_BAM_FILE 		:="$FINAL_BAM_PREFIX.bam" //# To be stored
		FINAL_TA_FILE 		:="$FINAL_BAM_PREFIX.SE.tagAlign.gz"
		SUBSAMPLED_TA_FILE 	:="$OFPREFIX.filt.nodup.sample.$NREADS_PER_MILLION.SE.tagAlign.gz"

		task( taskName := "softlink_tagalign " + cat_ctl_rep(ctl, rep), \
			cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			SUBSAMPLED_TA_FILE <- tagalign ) { 

			sys $PRELOAD
		
			//# ===================
			//# Create tagAlign file
			//# ===================
			//# Create SE tagAlign file						
			sys ln -f -s $tagalign $FINAL_TA_FILE

			//# =================================
			//# Subsample tagAlign file
			//# ================================
			sys zcat $FINAL_TA_FILE | \
				grep -v "chrM" | shuf -n $NREADS | gzip -c > $SUBSAMPLED_TA_FILE
		}

		wait
	}
	else { // no data
		print("warning(softlink_tagalign): no input for ctl $ctl, rep $rep\n")
	}
}

void sig_trk() {

	if ( QC_ONLY ) {
		print("No signal track generation for QC_ONLY=true \n")
		return
	}
	
	for ( int ctl=0; ctl <= NUM_CTL; ctl++) { // iterate through fastqs (0: not control, 1~: controls)
		for ( int rep=1; rep <= NUM_REP; rep++) {
			par sig_trk( ctl, rep )
		}
	}
}

void sig_trk( int ctl, int rep ) {

	print( "\n====== sig_trk ctl:$ctl rep:$rep...\n" );

	OFPREFIX := get_ofprefix( ctl, rep )

	if ( !( is_paired_end( ctl, rep ) || is_single_ended( ctl, rep ) ) ) {
		print("warning(sig_trk): no input for ctl $ctl, rep $rep\n")
		return
	}

	FRAGLEN := get_fraglen( ctl, rep ) // get it from rep1
	print("\tFRAGLEN for signal track: $FRAGLEN \n")

 	string FINAL_BAM_PREFIX
	string FINAL_BAM_FILE
	string FINAL_TA_FILE 
	string WIG_FILE
	string BEDGRAPH_FILE
	string SORTED_BG_FILE
	string BIGWIG_FILE

	if ( is_paired_end( ctl, rep ) ) { // if data is paired-end
	 	FINAL_BAM_PREFIX ="$OFPREFIX.filt.srt.nodup"
		FINAL_BAM_FILE ="$FINAL_BAM_PREFIX.bam"
		FINAL_TA_FILE ="$FINAL_BAM_PREFIX.PE2SE.tagAlign.gz".path() // align2rawsignal needs absolute path
		WIG_FILE = "$FINAL_BAM_PREFIX.PE2SE.wig".path()
		BEDGRAPH_FILE = "$FINAL_BAM_PREFIX.PE2SE.bedGraph".path()
		SORTED_BG_FILE = "$FINAL_BAM_PREFIX.PE2SE.srt.bedGraph".path()
		BIGWIG_FILE = "$FINAL_BAM_PREFIX.PE2SE.bigwig".path()
	}
	else {
		FINAL_BAM_PREFIX ="$OFPREFIX.filt.nodup.srt"
		FINAL_BAM_FILE ="$FINAL_BAM_PREFIX.bam"
		FINAL_TA_FILE ="$FINAL_BAM_PREFIX.SE.tagAlign.gz".path()
		WIG_FILE = "$FINAL_BAM_PREFIX.SE.wig".path()
		BEDGRAPH_FILE = "$FINAL_BAM_PREFIX.SE.bedGraph".path()
		SORTED_BG_FILE = "$FINAL_BAM_PREFIX.SE.srt.bedGraph".path()
		BIGWIG_FILE = "$FINAL_BAM_PREFIX.SE.bigwig".path()
	}

	if ( CREATE_WIG ) {
			task( taskName := "make wig " + cat_ctl_rep(ctl, rep), \
				cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
				WIG_FILE <- FINAL_TA_FILE ) {

			sys $PRELOAD			

			sys align2rawsignal -i=$FINAL_TA_FILE -o=$WIG_FILE -s=$SEQ_DIR -u=$UMAP_DIR -of=wig -l=$FRAGLEN -mm=4
		}
	}

	if ( CREATE_BEDGRAPH ) {
		task( taskName := "make bedgraph " + cat_ctl_rep(ctl, rep), \
			cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			BEDGRAPH_FILE <- FINAL_TA_FILE ) {

			sys $PRELOAD
			
			sys align2rawsignal -i=$FINAL_TA_FILE -o=$BEDGRAPH_FILE -s=$SEQ_DIR -u=$UMAP_DIR -of=bg -l=$FRAGLEN -mm=4
		}

		if ( CONVERT_TO_BIGWIG ) {

			wait

			if ( BIGWIG_FILE <- BEDGRAPH_FILE ) {

				task( taskName := "sort bedgraph " + cat_ctl_rep(ctl, rep), \
					cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
					SORTED_BG_FILE <- BEDGRAPH_FILE ) {

					sys $PRELOAD

					sys sort -k1,1 -k2,2n $BEDGRAPH_FILE > $SORTED_BG_FILE
				}

				task( taskName := "make bigwig " + cat_ctl_rep(ctl, rep), \
					cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
					BIGWIG_FILE <- SORTED_BG_FILE ) {

					sys $PRELOAD
					
					sys bedGraphToBigWig $SORTED_BG_FILE $CHROM_SIZES $BIGWIG_FILE
					sys rm -f $SORTED_BG_FILE
				}
			}
		}
	}

}

void xcor( int ctl, int rep ) {

	print( "\n====== xcor ctl:$ctl rep:$rep...\n" );

	OFPREFIX := get_ofprefix( ctl, rep )	

	NREADS_PER_MILLION := NREADS/1000000
	
	if ( is_paired_end( ctl, rep ) || is_single_ended( ctl, rep ) ) {

		string SUBSAMPLED_TA_FILE = "" 

		// if data is paired-end, therefore PE1 and PE2

		if ( is_paired_end( ctl, rep ) )	SUBSAMPLED_TA_FILE = "$OFPREFIX.filt.nodup.sample.$NREADS_PER_MILLION.MATE1.tagAlign.gz"
		else 					SUBSAMPLED_TA_FILE = "$OFPREFIX.filt.nodup.sample.$NREADS_PER_MILLION.SE.tagAlign.gz"

		CC_SCORES_FILE :="$SUBSAMPLED_TA_FILE.cc.qc"
		CC_PLOT_FILE :="$SUBSAMPLED_TA_FILE.cc.plot.pdf"

		task( taskName := "xcor " + cat_ctl_rep(ctl, rep), \
			cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			[CC_SCORES_FILE, CC_PLOT_FILE] <- SUBSAMPLED_TA_FILE ) {

			sys $PRELOAD

			//# CCSCORE FILE format
			//# Filename <tab> numReads <tab> estFragLen <tab> correstFragLen <tab> PhantomPeak <tab> corrphantomPeak <tab> argmincorr <tab> mincorr <tab> phantomPeakCoef <tab> relPhantomPeakCoef <tab> QualityTag
			
			sys Rscript $(which run_spp_nodups.R) \
				-c=$SUBSAMPLED_TA_FILE -p=$NTHREADS \
				-filtchr=chrM -savp=$CC_PLOT_FILE -out=$CC_SCORES_FILE
			sys sed -r 's/,[^\t]+//g' $CC_SCORES_FILE > $OFPREFIX.tmp2
			sys mv $OFPREFIX.tmp2 $CC_SCORES_FILE
		}

		wait
	}
	else {
		print("warning(xcor): no input for ctl $ctl, rep $rep\n")
	}
}

void spr( int ctl, int rep ) { // self-pseudo-replicate
	print( "\n====== spr ctl:$ctl rep:$rep...\n" );

	OFPREFIX := get_ofprefix( ctl, rep )

	if ( is_paired_end( ctl, rep ) ) {

		FINAL_NMSRT_BAM_PREFIX 	:="$OFPREFIX.filt.nmsrt.nodup"
		FINAL_NMSRT_BAM_FILE 	:="$FINAL_NMSRT_BAM_PREFIX.bam" //# To be stored
		FINAL_BEDPE_FILE 	:="$FINAL_NMSRT_BAM_PREFIX.bedpe.gz"
		PR_PREFIX 		:="$OFPREFIX.filt.nodup"
		PR1_TA_FILE 		:="$PR_PREFIX.PE2SE.pr1.tagAlign.gz"
		PR2_TA_FILE 		:="$PR_PREFIX.PE2SE.pr2.tagAlign.gz"

		task( taskName := "make pseudo-rep. " + cat_ctl_rep(ctl, rep), \
			cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			[PR1_TA_FILE, PR2_TA_FILE] <- FINAL_BEDPE_FILE ) {

			sys $PRELOAD

			//# ========================
			//# Create pseudoReplicates
			//# =======================

			//# Get total number of read pairs
			//# Shuffle and split BEDPE file into 2 equal parts
			//# Will produce $PR_PREFIX00 and $PR_PREFIX01
			sys nlines=$( zcat $FINAL_BEDPE_FILE | wc -l ); nlines=$(( (nlines + 1) / 2 )); zcat $FINAL_BEDPE_FILE | shuf | split -d -l $((nlines)) - $PR_PREFIX. 

			//# Convert read pairs to reads into standard tagAlign file
			sys awk 'BEGIN{OFS="\t"}{printf "%s\t%s\t%s\tN\t1000\t%s\n%s\t%s\t%s\tN\t1000\t%s\n",$1,$2,$3,$9,$4,$5,$6,$10}' "$PR_PREFIX.00" | \
				gzip -c > $PR1_TA_FILE
			sys rm -f $PR_PREFIX.00
			sys awk 'BEGIN{OFS="\t"}{printf "%s\t%s\t%s\tN\t1000\t%s\n%s\t%s\t%s\tN\t1000\t%s\n",$1,$2,$3,$9,$4,$5,$6,$10}' "$PR_PREFIX.01" | \
				gzip -c > $PR2_TA_FILE
			sys rm -f $PR_PREFIX.01
		}

		wait

	}
	if ( is_single_ended( ctl, rep ) ) {

		FINAL_BAM_PREFIX :="$OFPREFIX.filt.nodup.srt"
		FINAL_TA_FILE 	:="$FINAL_BAM_PREFIX.SE.tagAlign.gz"
		PR_PREFIX 	:="$OFPREFIX.filt.nodup"
		PR1_TA_FILE 	:="$PR_PREFIX.SE.pr1.tagAlign.gz"
		PR2_TA_FILE 	:="$PR_PREFIX.SE.pr2.tagAlign.gz"

		task( taskName := "make pseudo-rep. " + cat_ctl_rep(ctl, rep), \
			cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
			[PR1_TA_FILE, PR2_TA_FILE] <- FINAL_TA_FILE ) {

			sys $PRELOAD

			//# ========================
			//# Create pseudoReplicates
			//# =======================

			//# Get total number of read pairs
			//# Shuffle and split BEDPE file into 2 equal parts
			//# Will produce $PR_PREFIX00 and $PR_PREFIX01
			sys nlines=$( zcat $FINAL_TA_FILE | wc -l ); nlines=$(( (nlines + 1) / 2 )); zcat $FINAL_TA_FILE | shuf | split -d -l $((nlines)) - $PR_PREFIX.

			//# Convert read pairs to reads into standard tagAlign file
			sys gzip -c $PR_PREFIX.00 > $PR1_TA_FILE
			sys rm -f $PR_PREFIX.00
			sys gzip -c $PR_PREFIX.01 > $PR2_TA_FILE
			sys rm -f $PR_PREFIX.01
		}

		wait 

	}
	else { // no data				
		print("warning(spr): no input for ctl $ctl, rep $rep\n")
	}
}

void pspr( int ctl ) {

	print( "\n====== pspr ctl:$ctl...\n" );

	DATASET_PREFIX := get_ofprefix( ctl )

	suffix_PE 	:= ".filt.srt.nodup.PE2SE.tagAlign.gz"
	suffix_SE 	:= ".filt.nodup.srt.SE.tagAlign.gz"
	suffix_PSR_PE 	:= ".filt.nodup.PE2SE"
	suffix_PSR_SE 	:= ".filt.nodup.SE"

	suffix 		:= is_paired_end( ctl, 1 ) ? suffix_PE : suffix_SE		
	suffix_PSR 	:= is_paired_end( ctl, 1 ) ? suffix_PSR_PE : suffix_PSR_SE

	REP1_TA_FILE :="$DATASET_PREFIX"+"_Rep1" + suffix
	REP2_TA_FILE :="$DATASET_PREFIX"+"_Rep2" + suffix

	POOLED_TA_FILE :="$DATASET_PREFIX"+"_Rep0.tagAlign.gz"

	REP1_PR1_TA_FILE :="$DATASET_PREFIX"+"_Rep1" + suffix_PSR + ".pr1.tagAlign.gz"
	REP1_PR2_TA_FILE :="$DATASET_PREFIX"+"_Rep1" + suffix_PSR + ".pr2.tagAlign.gz"

	REP2_PR1_TA_FILE :="$DATASET_PREFIX"+"_Rep2" + suffix_PSR + ".pr1.tagAlign.gz"
	REP2_PR2_TA_FILE :="$DATASET_PREFIX"+"_Rep2" + suffix_PSR + ".pr2.tagAlign.gz"

	PPR1_TA_FILE :="$DATASET_PREFIX"+"_Rep0.pr1.tagAlign.gz"
	PPR2_TA_FILE :="$DATASET_PREFIX"+"_Rep0.pr2.tagAlign.gz"

	if ( is_rep2_exist( ctl ) ) { 

		if ( PPR2_TA_FILE <- [REP1_TA_FILE, REP2_TA_FILE] ) {

			task( taskName := "pooled tagAlign (ctl:"+ctl+")", \
				cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
				POOLED_TA_FILE <- [REP1_TA_FILE, REP2_TA_FILE] ) {

				sys $PRELOAD

				//# ========================
				//# Create pooled datasets
				//# =======================
				sys zcat $REP1_TA_FILE $REP2_TA_FILE | gzip -c > $POOLED_TA_FILE
			}

			task( taskName := "ppr1 tagAlign (ctl:"+ctl+")", \
				cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
				PPR1_TA_FILE <- [REP1_PR1_TA_FILE, REP2_PR1_TA_FILE] ) {

				sys $PRELOAD

				//# ========================
				//# Create pooled pseudoreplicates
				//# =======================
				sys zcat $REP1_PR1_TA_FILE $REP2_PR1_TA_FILE | gzip -c > $PPR1_TA_FILE
			}

			task( taskName := "ppr2 tagAlign (ctl:"+ctl+")", \
				cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
				PPR2_TA_FILE <- [REP1_PR2_TA_FILE, REP2_PR2_TA_FILE] ) {

				sys $PRELOAD

				sys zcat $REP1_PR2_TA_FILE $REP2_PR2_TA_FILE | gzip -c > $PPR2_TA_FILE			
			}

			wait

		}
	}
	else { // if no data for rep2, just duplicate rep1

		if ( PPR2_TA_FILE <- REP1_TA_FILE ) {

			task( taskName := "pooled tagAlign (ctl:"+ctl+")", \
				cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
				POOLED_TA_FILE <- REP1_TA_FILE ) {

				sys $PRELOAD

				//# ======================== 
				//# Create pooled datasets
				//# =======================
				sys cp $REP1_TA_FILE $POOLED_TA_FILE			
			}

			task( taskName := "ppr1 tagAlign (ctl:"+ctl+")", \
				cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
				PPR1_TA_FILE <- REP1_PR1_TA_FILE ) {

				sys $PRELOAD

				//# ========================
				//# Create pooled pseudoreplicates
				//# =======================
				sys cp $REP1_PR1_TA_FILE $PPR1_TA_FILE			
			}

			task( taskName := "ppr2 tagAlign (ctl:"+ctl+")", \
				cpus := NTHREADS, timeout := WALLTIME, mem := MEMORY * M, \
				PPR2_TA_FILE <- REP1_PR2_TA_FILE ) {

				sys $PRELOAD

				sys cp $REP1_PR2_TA_FILE $PPR2_TA_FILE
			}

			wait
			
		}
	}
	
}

void init_cmd_line_arg_fastqs() {

	if ( fastq1 != "" ) fastq1_1 = fastq1
	if ( fastq2 != "" ) fastq2_1 = fastq2
	if ( ctl_fastq1 != "" ) ctl_fastq1_1 = ctl_fastq1
	if ( ctl_fastq2 != "" ) ctl_fastq2_1 = ctl_fastq2
}

string cat_ctl_rep( int ctl, int rep ) {
	return "(ctl: " + ctl + ", rep: " + rep + ")";
}

string get_ofprefix( int ctl, int rep ) {
	return OUTPUT_DIR + "/" + PREFIX + ( ctl>0 ? "_Ctl" : "" ) + "_Rep" + rep 
}

string get_ofprefix( int ctl ) {
	return OUTPUT_DIR + "/" + PREFIX + ( ctl>0 ? "_Ctl" : "" )
}

string get_fraglen( int ctl, int rep ) {  // get FRAGLEN (3rd column of cc score file) for spp(-speak=$FRAGLEN)
	
	NREADS_PER_MILLION := NREADS/1000000
	OFPREFIX := get_ofprefix( ctl, rep )	
	CC_SCORE_FILE := is_paired_end( ctl, rep ) ? "$OFPREFIX.filt.nodup.sample.$NREADS_PER_MILLION.MATE1.tagAlign.gz.cc.qc" : \
							"$OFPREFIX.filt.nodup.sample.$NREADS_PER_MILLION.SE.tagAlign.gz.cc.qc"
	cols := CC_SCORE_FILE.read().split("\t")
	return cols[2]
}

string[] get_fastqs( int ctl, int rep ) { 
	// if paired-end return [PE1, PE2], elseif single-end else return [PE1], else []
	string[] ret

	for ( int pe=1; pe<=2; pe++ ) {
		str := get_fastq( ctl, rep, pe )

		if ( str.length() > 0 ) { // if not null, append
			ret.add( str )
		}
	}

	return ret
}

string get_fastq( int ctl, int rep, int pe ) {

	key_wo_PE := ( ctl > 0 ? "INPUT_FASTQ_CTL" : "INPUT_FASTQ" ) + "_REP" + rep 
	key := key_wo_PE + "_PE" + pe

	if ( (pe==1) && conf.hasKey( key_wo_PE ) ) {
		return get_path( conf{ key_wo_PE } )
	}
	else if ( conf.hasKey( key ) ) {
		return get_path( conf{ key } )
	}
	else if ( (ctl==0) && (rep==1) && (pe==1) ) {
		return fastq1_1
	}
	else if ( (ctl==0) && (rep==1) && (pe==2) ) {
		return fastq1_2
	}
	else if ( (ctl==0) && (rep==2) && (pe==1) ) {
		return fastq2_1
	}
	else if ( (ctl==0) && (rep==2) && (pe==2) ) {
		return fastq2_2
	}
	else if ( (ctl==1) && (rep==1) && (pe==1) ) {
		return ctl_fastq1_1
	}
	else if ( (ctl==1) && (rep==1) && (pe==2) ) {
		return ctl_fastq1_2
	}
	else if ( (ctl==1) && (rep==2) && (pe==1) ) {
		return ctl_fastq2_1
	}
	else if ( (ctl==1) && (rep==2) && (pe==2) ) {
		return ctl_fastq2_2
	}
	else {
		return ""
	}
}

string get_tagalign( int ctl, int rep ) {

	key := ( ctl > 0 ? "INPUT_TAGALIGN_CTL" : "INPUT_TAGALIGN" ) + "_REP" + rep

	if ( conf.hasKey( key ) ) {
		return get_path( conf{ key } )
	}
	else if ( (ctl==0) && (rep==1) ) {
		return tagalign1
	}
	else if ( (ctl==0) && (rep==2) ) {
		return tagalign2
	}
	else if ( (ctl==1) && (rep==1) ) {
		return ctl_tagalign1
	}
	else if ( (ctl==1) && (rep==2) ) {
		return ctl_tagalign2
	}
	else {
		return ""
	}
}

bool is_input_fastq() {
	return INPUT_TYPE.toLower() == "fastq"
}

bool is_input_tagalign() {
	return INPUT_TYPE.toLower() == "tagalign"
}

bool is_rep2_exist( int ctl ) {
	if ( is_input_fastq() ) {
		fastqs := get_fastqs( ctl, 2 )
		return fastqs.size()>0
	}
	else if ( is_input_tagalign() ) {
		tagalign := get_tagalign( ctl, 2 )
		return tagalign!=""
	}
	return false;
}

bool is_paired_end( int ctl, int rep ) {

	if ( is_input_fastq() ) {
		fastqs := get_fastqs( ctl, rep )
		return fastqs.size()==2
	}
	else if ( is_input_tagalign() ) {
		tagalign := get_tagalign( ctl, rep )
		return (tagalign!="") && tagalign_PE
	}
	return false;
}

bool is_single_ended( int ctl, int rep ) {

	if ( is_input_fastq() ) {
		fastqs := get_fastqs( ctl, rep )
		return fastqs.size()==1
	}
	else if ( is_input_tagalign() ) {
		tagalign := get_tagalign( ctl, rep )
		return (tagalign!="") && (!tagalign_PE)
	}
	return false;
}
